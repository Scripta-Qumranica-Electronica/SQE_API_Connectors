/* tslint:disable */
/* eslint-disable */
/**
 * SQE API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AdminEditorRequestListDTO,
    AdminEditorRequestListDTOFromJSON,
    AdminEditorRequestListDTOToJSON,
    DeleteTokenDTO,
    DeleteTokenDTOFromJSON,
    DeleteTokenDTOToJSON,
    DetailedEditorRightsDTO,
    DetailedEditorRightsDTOFromJSON,
    DetailedEditorRightsDTOToJSON,
    EditionCopyDTO,
    EditionCopyDTOFromJSON,
    EditionCopyDTOToJSON,
    EditionDTO,
    EditionDTOFromJSON,
    EditionDTOToJSON,
    EditionGroupDTO,
    EditionGroupDTOFromJSON,
    EditionGroupDTOToJSON,
    EditionListDTO,
    EditionListDTOFromJSON,
    EditionListDTOToJSON,
    EditionScriptCollectionDTO,
    EditionScriptCollectionDTOFromJSON,
    EditionScriptCollectionDTOToJSON,
    EditionScriptLinesDTO,
    EditionScriptLinesDTOFromJSON,
    EditionScriptLinesDTOToJSON,
    EditionUpdateRequestDTO,
    EditionUpdateRequestDTOFromJSON,
    EditionUpdateRequestDTOToJSON,
    EditorInvitationListDTO,
    EditorInvitationListDTOFromJSON,
    EditorInvitationListDTOToJSON,
    InviteEditorDTO,
    InviteEditorDTOFromJSON,
    InviteEditorDTOToJSON,
    UpdateEditorRightsDTO,
    UpdateEditorRightsDTOFromJSON,
    UpdateEditorRightsDTOToJSON,
} from '../models';

export interface V1EditionsConfirmEditorshipTokenPostRequest {
    token: string;
}

export interface V1EditionsEditionIdAddEditorRequestPostRequest {
    editionId: number;
    inviteEditorDTO?: InviteEditorDTO;
}

export interface V1EditionsEditionIdDeleteRequest {
    editionId: number;
    optional?: Array<string>;
    token?: string;
}

export interface V1EditionsEditionIdEditorsEditorEmailIdPutRequest {
    editionId: number;
    editorEmailId: string;
    updateEditorRightsDTO?: UpdateEditorRightsDTO;
}

export interface V1EditionsEditionIdGetRequest {
    editionId: number;
}

export interface V1EditionsEditionIdPostRequest {
    editionId: number;
    editionCopyDTO?: EditionCopyDTO;
}

export interface V1EditionsEditionIdPutRequest {
    editionId: number;
    editionUpdateRequestDTO?: EditionUpdateRequestDTO;
}

export interface V1EditionsEditionIdScriptCollectionGetRequest {
    editionId: number;
}

export interface V1EditionsEditionIdScriptLinesGetRequest {
    editionId: number;
}

/**
 * 
 */
export class EditionApi extends runtime.BaseAPI {

    /**
     * Get a list of requests issued by the current user for other users  to become editors of a shared edition
     */
    async v1EditionsAdminShareRequestsGetRaw(): Promise<runtime.ApiResponse<AdminEditorRequestListDTO>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/admin-share-requests`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AdminEditorRequestListDTOFromJSON(jsonValue));
    }

    /**
     * Get a list of requests issued by the current user for other users  to become editors of a shared edition
     */
    async v1EditionsAdminShareRequestsGet(): Promise<AdminEditorRequestListDTO> {
        const response = await this.v1EditionsAdminShareRequestsGetRaw();
        return await response.value();
    }

    /**
     * Confirm addition of an editor to the specified edition
     */
    async v1EditionsConfirmEditorshipTokenPostRaw(requestParameters: V1EditionsConfirmEditorshipTokenPostRequest): Promise<runtime.ApiResponse<DetailedEditorRightsDTO>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling v1EditionsConfirmEditorshipTokenPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/confirm-editorship/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DetailedEditorRightsDTOFromJSON(jsonValue));
    }

    /**
     * Confirm addition of an editor to the specified edition
     */
    async v1EditionsConfirmEditorshipTokenPost(requestParameters: V1EditionsConfirmEditorshipTokenPostRequest): Promise<DetailedEditorRightsDTO> {
        const response = await this.v1EditionsConfirmEditorshipTokenPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Adds an editor to the specified edition
     */
    async v1EditionsEditionIdAddEditorRequestPostRaw(requestParameters: V1EditionsEditionIdAddEditorRequestPostRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdAddEditorRequestPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/add-editor-request`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InviteEditorDTOToJSON(requestParameters.inviteEditorDTO),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Adds an editor to the specified edition
     */
    async v1EditionsEditionIdAddEditorRequestPost(requestParameters: V1EditionsEditionIdAddEditorRequestPostRequest): Promise<void> {
        await this.v1EditionsEditionIdAddEditorRequestPostRaw(requestParameters);
    }

    /**
     * Provides details about the specified edition and all accessible alternate editions
     */
    async v1EditionsEditionIdDeleteRaw(requestParameters: V1EditionsEditionIdDeleteRequest): Promise<runtime.ApiResponse<DeleteTokenDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.optional) {
            queryParameters['optional'] = requestParameters.optional;
        }

        if (requestParameters.token !== undefined) {
            queryParameters['token'] = requestParameters.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteTokenDTOFromJSON(jsonValue));
    }

    /**
     * Provides details about the specified edition and all accessible alternate editions
     */
    async v1EditionsEditionIdDelete(requestParameters: V1EditionsEditionIdDeleteRequest): Promise<DeleteTokenDTO> {
        const response = await this.v1EditionsEditionIdDeleteRaw(requestParameters);
        return await response.value();
    }

    /**
     * Changes the rights for an editor of the specified edition
     */
    async v1EditionsEditionIdEditorsEditorEmailIdPutRaw(requestParameters: V1EditionsEditionIdEditorsEditorEmailIdPutRequest): Promise<runtime.ApiResponse<DetailedEditorRightsDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdEditorsEditorEmailIdPut.');
        }

        if (requestParameters.editorEmailId === null || requestParameters.editorEmailId === undefined) {
            throw new runtime.RequiredError('editorEmailId','Required parameter requestParameters.editorEmailId was null or undefined when calling v1EditionsEditionIdEditorsEditorEmailIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/editors/{editorEmailId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"editorEmailId"}}`, encodeURIComponent(String(requestParameters.editorEmailId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEditorRightsDTOToJSON(requestParameters.updateEditorRightsDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DetailedEditorRightsDTOFromJSON(jsonValue));
    }

    /**
     * Changes the rights for an editor of the specified edition
     */
    async v1EditionsEditionIdEditorsEditorEmailIdPut(requestParameters: V1EditionsEditionIdEditorsEditorEmailIdPutRequest): Promise<DetailedEditorRightsDTO> {
        const response = await this.v1EditionsEditionIdEditorsEditorEmailIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Provides details about the specified edition and all accessible alternate editions
     */
    async v1EditionsEditionIdGetRaw(requestParameters: V1EditionsEditionIdGetRequest): Promise<runtime.ApiResponse<EditionGroupDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EditionGroupDTOFromJSON(jsonValue));
    }

    /**
     * Provides details about the specified edition and all accessible alternate editions
     */
    async v1EditionsEditionIdGet(requestParameters: V1EditionsEditionIdGetRequest): Promise<EditionGroupDTO> {
        const response = await this.v1EditionsEditionIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a copy of the specified edition
     */
    async v1EditionsEditionIdPostRaw(requestParameters: V1EditionsEditionIdPostRequest): Promise<runtime.ApiResponse<EditionDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EditionCopyDTOToJSON(requestParameters.editionCopyDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EditionDTOFromJSON(jsonValue));
    }

    /**
     * Creates a copy of the specified edition
     */
    async v1EditionsEditionIdPost(requestParameters: V1EditionsEditionIdPostRequest): Promise<EditionDTO> {
        const response = await this.v1EditionsEditionIdPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates data for the specified edition
     */
    async v1EditionsEditionIdPutRaw(requestParameters: V1EditionsEditionIdPutRequest): Promise<runtime.ApiResponse<EditionDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditionUpdateRequestDTOToJSON(requestParameters.editionUpdateRequestDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EditionDTOFromJSON(jsonValue));
    }

    /**
     * Updates data for the specified edition
     */
    async v1EditionsEditionIdPut(requestParameters: V1EditionsEditionIdPutRequest): Promise<EditionDTO> {
        const response = await this.v1EditionsEditionIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Provides spatial data for all letters in the edition
     */
    async v1EditionsEditionIdScriptCollectionGetRaw(requestParameters: V1EditionsEditionIdScriptCollectionGetRequest): Promise<runtime.ApiResponse<EditionScriptCollectionDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdScriptCollectionGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/script-collection`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EditionScriptCollectionDTOFromJSON(jsonValue));
    }

    /**
     * Provides spatial data for all letters in the edition
     */
    async v1EditionsEditionIdScriptCollectionGet(requestParameters: V1EditionsEditionIdScriptCollectionGetRequest): Promise<EditionScriptCollectionDTO> {
        const response = await this.v1EditionsEditionIdScriptCollectionGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Provides spatial data for all letters in the edition organized and oriented  by lines.
     */
    async v1EditionsEditionIdScriptLinesGetRaw(requestParameters: V1EditionsEditionIdScriptLinesGetRequest): Promise<runtime.ApiResponse<EditionScriptLinesDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdScriptLinesGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/script-lines`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EditionScriptLinesDTOFromJSON(jsonValue));
    }

    /**
     * Provides spatial data for all letters in the edition organized and oriented  by lines.
     */
    async v1EditionsEditionIdScriptLinesGet(requestParameters: V1EditionsEditionIdScriptLinesGetRequest): Promise<EditionScriptLinesDTO> {
        const response = await this.v1EditionsEditionIdScriptLinesGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of invitations issued to the current user to become an editor of a shared edition
     */
    async v1EditionsEditorInvitationsGetRaw(): Promise<runtime.ApiResponse<EditorInvitationListDTO>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/editor-invitations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EditorInvitationListDTOFromJSON(jsonValue));
    }

    /**
     * Get a list of invitations issued to the current user to become an editor of a shared edition
     */
    async v1EditionsEditorInvitationsGet(): Promise<EditorInvitationListDTO> {
        const response = await this.v1EditionsEditorInvitationsGetRaw();
        return await response.value();
    }

    /**
     * Provides a listing of all editions accessible to the current user
     */
    async v1EditionsGetRaw(): Promise<runtime.ApiResponse<EditionListDTO>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EditionListDTOFromJSON(jsonValue));
    }

    /**
     * Provides a listing of all editions accessible to the current user
     */
    async v1EditionsGet(): Promise<EditionListDTO> {
        const response = await this.v1EditionsGetRaw();
        return await response.value();
    }

}
