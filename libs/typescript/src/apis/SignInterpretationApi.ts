/* tslint:disable */
/* eslint-disable */
/**
 * SQE API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AttributeDTO,
    AttributeDTOFromJSON,
    AttributeDTOToJSON,
    AttributeListDTO,
    AttributeListDTOFromJSON,
    AttributeListDTOToJSON,
    CommentaryCreateDTO,
    CommentaryCreateDTOFromJSON,
    CommentaryCreateDTOToJSON,
    CreateAttributeDTO,
    CreateAttributeDTOFromJSON,
    CreateAttributeDTOToJSON,
    InterpretationAttributeCreateDTO,
    InterpretationAttributeCreateDTOFromJSON,
    InterpretationAttributeCreateDTOToJSON,
    SignInterpretationCreateDTO,
    SignInterpretationCreateDTOFromJSON,
    SignInterpretationCreateDTOToJSON,
    SignInterpretationDTO,
    SignInterpretationDTOFromJSON,
    SignInterpretationDTOToJSON,
    SignInterpretationListDTO,
    SignInterpretationListDTOFromJSON,
    SignInterpretationListDTOToJSON,
    UpdateAttributeDTO,
    UpdateAttributeDTOFromJSON,
    UpdateAttributeDTOToJSON,
} from '../models';

export interface V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest {
    editionId: number;
    attributeId: number;
}

export interface V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest {
    editionId: number;
    attributeId: number;
    updateAttributeDTO?: UpdateAttributeDTO;
}

export interface V1EditionsEditionIdSignInterpretationsAttributesGetRequest {
    editionId: number;
}

export interface V1EditionsEditionIdSignInterpretationsAttributesPostRequest {
    editionId: number;
    createAttributeDTO?: CreateAttributeDTO;
}

export interface V1EditionsEditionIdSignInterpretationsPostRequest {
    editionId: number;
    signInterpretationCreateDTO?: SignInterpretationCreateDTO;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest {
    editionId: number;
    signInterpretationId: number;
    attributeValueId: number;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest {
    editionId: number;
    signInterpretationId: number;
    attributeValueId: number;
    interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest {
    editionId: number;
    signInterpretationId: number;
    interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest {
    editionId: number;
    signInterpretationId: number;
    commentaryCreateDTO?: CommentaryCreateDTO;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest {
    editionId: number;
    signInterpretationId: number;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest {
    editionId: number;
    signInterpretationId: number;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest {
    editionId: number;
    signInterpretationId: number;
    nextSignInterpretationId: number;
}

export interface V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest {
    editionId: number;
    signInterpretationId: number;
    nextSignInterpretationId: number;
}

/**
 * 
 */
export class SignInterpretationApi extends runtime.BaseAPI {

    /**
     * Delete an attribute from an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRaw(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete.');
        }

        if (requestParameters.attributeId === null || requestParameters.attributeId === undefined) {
            throw new runtime.RequiredError('attributeId','Required parameter requestParameters.attributeId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"attributeId"}}`, encodeURIComponent(String(requestParameters.attributeId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an attribute from an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest): Promise<void> {
        await this.v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRaw(requestParameters);
    }

    /**
     * Change the details of an attribute in an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRaw(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest): Promise<runtime.ApiResponse<AttributeDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut.');
        }

        if (requestParameters.attributeId === null || requestParameters.attributeId === undefined) {
            throw new runtime.RequiredError('attributeId','Required parameter requestParameters.attributeId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"attributeId"}}`, encodeURIComponent(String(requestParameters.attributeId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAttributeDTOToJSON(requestParameters.updateAttributeDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttributeDTOFromJSON(jsonValue));
    }

    /**
     * Change the details of an attribute in an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest): Promise<AttributeDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a list of all possible attributes for an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesGetRaw(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesGetRequest): Promise<runtime.ApiResponse<AttributeListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations-attributes`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttributeListDTOFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all possible attributes for an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesGet(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesGetRequest): Promise<AttributeListDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsAttributesGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new attribute for an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesPostRaw(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesPostRequest): Promise<runtime.ApiResponse<AttributeDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations-attributes`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAttributeDTOToJSON(requestParameters.createAttributeDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttributeDTOFromJSON(jsonValue));
    }

    /**
     * Create a new attribute for an edition
     */
    async v1EditionsEditionIdSignInterpretationsAttributesPost(requestParameters: V1EditionsEditionIdSignInterpretationsAttributesPostRequest): Promise<AttributeDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsAttributesPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new sign interpretation
     */
    async v1EditionsEditionIdSignInterpretationsPostRaw(requestParameters: V1EditionsEditionIdSignInterpretationsPostRequest): Promise<runtime.ApiResponse<SignInterpretationListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignInterpretationCreateDTOToJSON(requestParameters.signInterpretationCreateDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SignInterpretationListDTOFromJSON(jsonValue));
    }

    /**
     * Creates a new sign interpretation
     */
    async v1EditionsEditionIdSignInterpretationsPost(requestParameters: V1EditionsEditionIdSignInterpretationsPostRequest): Promise<SignInterpretationListDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * This deletes the specified attribute value from the specified sign interpretation.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete.');
        }

        if (requestParameters.attributeValueId === null || requestParameters.attributeValueId === undefined) {
            throw new runtime.RequiredError('attributeValueId','Required parameter requestParameters.attributeValueId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))).replace(`{${"attributeValueId"}}`, encodeURIComponent(String(requestParameters.attributeValueId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This deletes the specified attribute value from the specified sign interpretation.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest): Promise<void> {
        await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRaw(requestParameters);
    }

    /**
     * This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest): Promise<runtime.ApiResponse<SignInterpretationDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut.');
        }

        if (requestParameters.attributeValueId === null || requestParameters.attributeValueId === undefined) {
            throw new runtime.RequiredError('attributeValueId','Required parameter requestParameters.attributeValueId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))).replace(`{${"attributeValueId"}}`, encodeURIComponent(String(requestParameters.attributeValueId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InterpretationAttributeCreateDTOToJSON(requestParameters.interpretationAttributeCreateDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SignInterpretationDTOFromJSON(jsonValue));
    }

    /**
     * This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest): Promise<SignInterpretationDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * This adds a new attribute to the specified sign interpretation.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest): Promise<runtime.ApiResponse<SignInterpretationDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InterpretationAttributeCreateDTOToJSON(requestParameters.interpretationAttributeCreateDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SignInterpretationDTOFromJSON(jsonValue));
    }

    /**
     * This adds a new attribute to the specified sign interpretation.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest): Promise<SignInterpretationDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates the commentary of a sign interpretation
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest): Promise<runtime.ApiResponse<SignInterpretationDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/commentary`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CommentaryCreateDTOToJSON(requestParameters.commentaryCreateDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SignInterpretationDTOFromJSON(jsonValue));
    }

    /**
     * Updates the commentary of a sign interpretation
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest): Promise<SignInterpretationDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign\'s next and previous nodes.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign\'s next and previous nodes.
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest): Promise<void> {
        await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRaw(requestParameters);
    }

    /**
     * Retrieve the details of a sign interpretation in an edition
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest): Promise<runtime.ApiResponse<SignInterpretationDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SignInterpretationDTOFromJSON(jsonValue));
    }

    /**
     * Retrieve the details of a sign interpretation in an edition
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest): Promise<SignInterpretationDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Links two sign interpretations in the edition\'s sign stream
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest): Promise<runtime.ApiResponse<SignInterpretationDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost.');
        }

        if (requestParameters.nextSignInterpretationId === null || requestParameters.nextSignInterpretationId === undefined) {
            throw new runtime.RequiredError('nextSignInterpretationId','Required parameter requestParameters.nextSignInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/link-to/{nextSignInterpretationId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))).replace(`{${"nextSignInterpretationId"}}`, encodeURIComponent(String(requestParameters.nextSignInterpretationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SignInterpretationDTOFromJSON(jsonValue));
    }

    /**
     * Links two sign interpretations in the edition\'s sign stream
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest): Promise<SignInterpretationDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Links two sign interpretations in the edition\'s sign stream
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRaw(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest): Promise<runtime.ApiResponse<SignInterpretationDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost.');
        }

        if (requestParameters.signInterpretationId === null || requestParameters.signInterpretationId === undefined) {
            throw new runtime.RequiredError('signInterpretationId','Required parameter requestParameters.signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost.');
        }

        if (requestParameters.nextSignInterpretationId === null || requestParameters.nextSignInterpretationId === undefined) {
            throw new runtime.RequiredError('nextSignInterpretationId','Required parameter requestParameters.nextSignInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/unlink-from/{nextSignInterpretationId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(requestParameters.signInterpretationId))).replace(`{${"nextSignInterpretationId"}}`, encodeURIComponent(String(requestParameters.nextSignInterpretationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SignInterpretationDTOFromJSON(jsonValue));
    }

    /**
     * Links two sign interpretations in the edition\'s sign stream
     */
    async v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(requestParameters: V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest): Promise<SignInterpretationDTO> {
        const response = await this.v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRaw(requestParameters);
        return await response.value();
    }

}
