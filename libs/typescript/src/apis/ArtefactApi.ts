/* tslint:disable */
/* eslint-disable */
/**
 * SQE API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ArtefactDTO,
    ArtefactDTOFromJSON,
    ArtefactDTOToJSON,
    ArtefactGroupDTO,
    ArtefactGroupDTOFromJSON,
    ArtefactGroupDTOToJSON,
    ArtefactGroupListDTO,
    ArtefactGroupListDTOFromJSON,
    ArtefactGroupListDTOToJSON,
    ArtefactListDTO,
    ArtefactListDTOFromJSON,
    ArtefactListDTOToJSON,
    ArtefactTextFragmentMatchListDTO,
    ArtefactTextFragmentMatchListDTOFromJSON,
    ArtefactTextFragmentMatchListDTOToJSON,
    BatchUpdateArtefactPlacementDTO,
    BatchUpdateArtefactPlacementDTOFromJSON,
    BatchUpdateArtefactPlacementDTOToJSON,
    BatchUpdatedArtefactTransformDTO,
    BatchUpdatedArtefactTransformDTOFromJSON,
    BatchUpdatedArtefactTransformDTOToJSON,
    CreateArtefactDTO,
    CreateArtefactDTOFromJSON,
    CreateArtefactDTOToJSON,
    CreateArtefactGroupDTO,
    CreateArtefactGroupDTOFromJSON,
    CreateArtefactGroupDTOToJSON,
    DeleteDTO,
    DeleteDTOFromJSON,
    DeleteDTOToJSON,
    InterpretationRoiDTOList,
    InterpretationRoiDTOListFromJSON,
    InterpretationRoiDTOListToJSON,
    UpdateArtefactDTO,
    UpdateArtefactDTOFromJSON,
    UpdateArtefactDTOToJSON,
    UpdateArtefactGroupDTO,
    UpdateArtefactGroupDTOFromJSON,
    UpdateArtefactGroupDTOToJSON,
} from '../models';

export interface V1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest {
    editionId: number;
    artefactGroupId: number;
}

export interface V1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest {
    editionId: number;
    artefactGroupId: number;
}

export interface V1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest {
    editionId: number;
    artefactGroupId: number;
    updateArtefactGroupDTO?: UpdateArtefactGroupDTO;
}

export interface V1EditionsEditionIdArtefactGroupsGetRequest {
    editionId: number;
}

export interface V1EditionsEditionIdArtefactGroupsPostRequest {
    editionId: number;
    createArtefactGroupDTO?: CreateArtefactGroupDTO;
}

export interface V1EditionsEditionIdArtefactsArtefactIdDeleteRequest {
    editionId: number;
    artefactId: number;
}

export interface V1EditionsEditionIdArtefactsArtefactIdGetRequest {
    editionId: number;
    artefactId: number;
    optional?: Array<string>;
}

export interface V1EditionsEditionIdArtefactsArtefactIdPutRequest {
    editionId: number;
    artefactId: number;
    updateArtefactDTO?: UpdateArtefactDTO;
}

export interface V1EditionsEditionIdArtefactsArtefactIdRoisGetRequest {
    editionId: number;
    artefactId: number;
}

export interface V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest {
    editionId: number;
    artefactId: number;
    optional?: Array<string>;
}

export interface V1EditionsEditionIdArtefactsBatchTransformationPostRequest {
    editionId: number;
    batchUpdateArtefactPlacementDTO?: BatchUpdateArtefactPlacementDTO;
}

export interface V1EditionsEditionIdArtefactsGetRequest {
    editionId: number;
    optional?: Array<string>;
}

export interface V1EditionsEditionIdArtefactsPostRequest {
    editionId: number;
    createArtefactDTO?: CreateArtefactDTO;
}

/**
 * 
 */
export class ArtefactApi extends runtime.BaseAPI {

    /**
     * Deletes the specified artefact group.
     */
    async v1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRaw(requestParameters: V1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest): Promise<runtime.ApiResponse<DeleteDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete.');
        }

        if (requestParameters.artefactGroupId === null || requestParameters.artefactGroupId === undefined) {
            throw new runtime.RequiredError('artefactGroupId','Required parameter requestParameters.artefactGroupId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefact-groups/{artefactGroupId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactGroupId"}}`, encodeURIComponent(String(requestParameters.artefactGroupId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteDTOFromJSON(jsonValue));
    }

    /**
     * Deletes the specified artefact group.
     */
    async v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(requestParameters: V1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest): Promise<DeleteDTO> {
        const response = await this.v1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets the details of a specific artefact group in the edition
     */
    async v1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRaw(requestParameters: V1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest): Promise<runtime.ApiResponse<ArtefactGroupDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet.');
        }

        if (requestParameters.artefactGroupId === null || requestParameters.artefactGroupId === undefined) {
            throw new runtime.RequiredError('artefactGroupId','Required parameter requestParameters.artefactGroupId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefact-groups/{artefactGroupId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactGroupId"}}`, encodeURIComponent(String(requestParameters.artefactGroupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactGroupDTOFromJSON(jsonValue));
    }

    /**
     * Gets the details of a specific artefact group in the edition
     */
    async v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(requestParameters: V1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest): Promise<ArtefactGroupDTO> {
        const response = await this.v1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates the details of an artefact group.  The artefact group will now only contain the artefacts listed in the JSON payload.  If the name is null, no change will be made, otherwise the name will also be updated.
     */
    async v1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRaw(requestParameters: V1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest): Promise<runtime.ApiResponse<ArtefactGroupDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut.');
        }

        if (requestParameters.artefactGroupId === null || requestParameters.artefactGroupId === undefined) {
            throw new runtime.RequiredError('artefactGroupId','Required parameter requestParameters.artefactGroupId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefact-groups/{artefactGroupId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactGroupId"}}`, encodeURIComponent(String(requestParameters.artefactGroupId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateArtefactGroupDTOToJSON(requestParameters.updateArtefactGroupDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactGroupDTOFromJSON(jsonValue));
    }

    /**
     * Updates the details of an artefact group.  The artefact group will now only contain the artefacts listed in the JSON payload.  If the name is null, no change will be made, otherwise the name will also be updated.
     */
    async v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(requestParameters: V1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest): Promise<ArtefactGroupDTO> {
        const response = await this.v1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets a listing of all artefact groups in the edition
     */
    async v1EditionsEditionIdArtefactGroupsGetRaw(requestParameters: V1EditionsEditionIdArtefactGroupsGetRequest): Promise<runtime.ApiResponse<ArtefactGroupListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefact-groups`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactGroupListDTOFromJSON(jsonValue));
    }

    /**
     * Gets a listing of all artefact groups in the edition
     */
    async v1EditionsEditionIdArtefactGroupsGet(requestParameters: V1EditionsEditionIdArtefactGroupsGetRequest): Promise<ArtefactGroupListDTO> {
        const response = await this.v1EditionsEditionIdArtefactGroupsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new artefact group with the submitted data.  The new artefact must have a list of artefacts that belong to the group.  It is not necessary to give the group a name.
     */
    async v1EditionsEditionIdArtefactGroupsPostRaw(requestParameters: V1EditionsEditionIdArtefactGroupsPostRequest): Promise<runtime.ApiResponse<ArtefactGroupDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefact-groups`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateArtefactGroupDTOToJSON(requestParameters.createArtefactGroupDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactGroupDTOFromJSON(jsonValue));
    }

    /**
     * Creates a new artefact group with the submitted data.  The new artefact must have a list of artefacts that belong to the group.  It is not necessary to give the group a name.
     */
    async v1EditionsEditionIdArtefactGroupsPost(requestParameters: V1EditionsEditionIdArtefactGroupsPostRequest): Promise<ArtefactGroupDTO> {
        const response = await this.v1EditionsEditionIdArtefactGroupsPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deletes the specified artefact
     */
    async v1EditionsEditionIdArtefactsArtefactIdDeleteRaw(requestParameters: V1EditionsEditionIdArtefactsArtefactIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdDelete.');
        }

        if (requestParameters.artefactId === null || requestParameters.artefactId === undefined) {
            throw new runtime.RequiredError('artefactId','Required parameter requestParameters.artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts/{artefactId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters.artefactId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the specified artefact
     */
    async v1EditionsEditionIdArtefactsArtefactIdDelete(requestParameters: V1EditionsEditionIdArtefactsArtefactIdDeleteRequest): Promise<void> {
        await this.v1EditionsEditionIdArtefactsArtefactIdDeleteRaw(requestParameters);
    }

    /**
     * Provides a listing of all artefacts that are part of the specified edition
     */
    async v1EditionsEditionIdArtefactsArtefactIdGetRaw(requestParameters: V1EditionsEditionIdArtefactsArtefactIdGetRequest): Promise<runtime.ApiResponse<ArtefactDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdGet.');
        }

        if (requestParameters.artefactId === null || requestParameters.artefactId === undefined) {
            throw new runtime.RequiredError('artefactId','Required parameter requestParameters.artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.optional) {
            queryParameters['optional'] = requestParameters.optional;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts/{artefactId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters.artefactId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactDTOFromJSON(jsonValue));
    }

    /**
     * Provides a listing of all artefacts that are part of the specified edition
     */
    async v1EditionsEditionIdArtefactsArtefactIdGet(requestParameters: V1EditionsEditionIdArtefactsArtefactIdGetRequest): Promise<ArtefactDTO> {
        const response = await this.v1EditionsEditionIdArtefactsArtefactIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates the specified artefact.  There are many possible attributes that can be changed for  an artefact.  The caller should only input only those that  should be changed. Attributes with a null value will be ignored.  For instance, setting the mask to null or \"\" will result in  no changes to the current mask, and no value for the mask will  be returned (or broadcast). Likewise, the transformation, name,  or status message may be set to null and no change will be made  to those entities (though any unchanged values will be returned  along with the changed values and also broadcast to co-editors).
     */
    async v1EditionsEditionIdArtefactsArtefactIdPutRaw(requestParameters: V1EditionsEditionIdArtefactsArtefactIdPutRequest): Promise<runtime.ApiResponse<ArtefactDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdPut.');
        }

        if (requestParameters.artefactId === null || requestParameters.artefactId === undefined) {
            throw new runtime.RequiredError('artefactId','Required parameter requestParameters.artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts/{artefactId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters.artefactId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateArtefactDTOToJSON(requestParameters.updateArtefactDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactDTOFromJSON(jsonValue));
    }

    /**
     * Updates the specified artefact.  There are many possible attributes that can be changed for  an artefact.  The caller should only input only those that  should be changed. Attributes with a null value will be ignored.  For instance, setting the mask to null or \"\" will result in  no changes to the current mask, and no value for the mask will  be returned (or broadcast). Likewise, the transformation, name,  or status message may be set to null and no change will be made  to those entities (though any unchanged values will be returned  along with the changed values and also broadcast to co-editors).
     */
    async v1EditionsEditionIdArtefactsArtefactIdPut(requestParameters: V1EditionsEditionIdArtefactsArtefactIdPutRequest): Promise<ArtefactDTO> {
        const response = await this.v1EditionsEditionIdArtefactsArtefactIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Provides a listing of all rois belonging to an artefact in the specified edition
     */
    async v1EditionsEditionIdArtefactsArtefactIdRoisGetRaw(requestParameters: V1EditionsEditionIdArtefactsArtefactIdRoisGetRequest): Promise<runtime.ApiResponse<InterpretationRoiDTOList>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdRoisGet.');
        }

        if (requestParameters.artefactId === null || requestParameters.artefactId === undefined) {
            throw new runtime.RequiredError('artefactId','Required parameter requestParameters.artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdRoisGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts/{artefactId}/rois`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters.artefactId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InterpretationRoiDTOListFromJSON(jsonValue));
    }

    /**
     * Provides a listing of all rois belonging to an artefact in the specified edition
     */
    async v1EditionsEditionIdArtefactsArtefactIdRoisGet(requestParameters: V1EditionsEditionIdArtefactsArtefactIdRoisGetRequest): Promise<InterpretationRoiDTOList> {
        const response = await this.v1EditionsEditionIdArtefactsArtefactIdRoisGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Provides a listing of text fragments that have text in the specified artefact.  With the optional query parameter \"suggested\", this endpoint will also return  any text fragment that the system suggests might have text in the artefact.
     */
    async v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRaw(requestParameters: V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest): Promise<runtime.ApiResponse<ArtefactTextFragmentMatchListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet.');
        }

        if (requestParameters.artefactId === null || requestParameters.artefactId === undefined) {
            throw new runtime.RequiredError('artefactId','Required parameter requestParameters.artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.optional) {
            queryParameters['optional'] = requestParameters.optional;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts/{artefactId}/text-fragments`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters.artefactId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactTextFragmentMatchListDTOFromJSON(jsonValue));
    }

    /**
     * Provides a listing of text fragments that have text in the specified artefact.  With the optional query parameter \"suggested\", this endpoint will also return  any text fragment that the system suggests might have text in the artefact.
     */
    async v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(requestParameters: V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest): Promise<ArtefactTextFragmentMatchListDTO> {
        const response = await this.v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates the positional data for a batch of artefacts
     */
    async v1EditionsEditionIdArtefactsBatchTransformationPostRaw(requestParameters: V1EditionsEditionIdArtefactsBatchTransformationPostRequest): Promise<runtime.ApiResponse<BatchUpdatedArtefactTransformDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsBatchTransformationPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts/batch-transformation`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BatchUpdateArtefactPlacementDTOToJSON(requestParameters.batchUpdateArtefactPlacementDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BatchUpdatedArtefactTransformDTOFromJSON(jsonValue));
    }

    /**
     * Updates the positional data for a batch of artefacts
     */
    async v1EditionsEditionIdArtefactsBatchTransformationPost(requestParameters: V1EditionsEditionIdArtefactsBatchTransformationPostRequest): Promise<BatchUpdatedArtefactTransformDTO> {
        const response = await this.v1EditionsEditionIdArtefactsBatchTransformationPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Provides a listing of all artefacts that are part of the specified edition
     */
    async v1EditionsEditionIdArtefactsGetRaw(requestParameters: V1EditionsEditionIdArtefactsGetRequest): Promise<runtime.ApiResponse<ArtefactListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.optional) {
            queryParameters['optional'] = requestParameters.optional;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactListDTOFromJSON(jsonValue));
    }

    /**
     * Provides a listing of all artefacts that are part of the specified edition
     */
    async v1EditionsEditionIdArtefactsGet(requestParameters: V1EditionsEditionIdArtefactsGetRequest): Promise<ArtefactListDTO> {
        const response = await this.v1EditionsEditionIdArtefactsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new artefact with the provided data.  If no mask is provided, a placeholder mask will be created with the values:  \"POLYGON((0 0,1 1,1 0,0 0))\" (the system requires a valid WKT polygon mask for  every artefact). It is not recommended to leave the mask, name, or work status  blank or null. It will often be advantageous to leave the transformation null  when first creating a new artefact.
     */
    async v1EditionsEditionIdArtefactsPostRaw(requestParameters: V1EditionsEditionIdArtefactsPostRequest): Promise<runtime.ApiResponse<ArtefactDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdArtefactsPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/artefacts`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateArtefactDTOToJSON(requestParameters.createArtefactDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactDTOFromJSON(jsonValue));
    }

    /**
     * Creates a new artefact with the provided data.  If no mask is provided, a placeholder mask will be created with the values:  \"POLYGON((0 0,1 1,1 0,0 0))\" (the system requires a valid WKT polygon mask for  every artefact). It is not recommended to leave the mask, name, or work status  blank or null. It will often be advantageous to leave the transformation null  when first creating a new artefact.
     */
    async v1EditionsEditionIdArtefactsPost(requestParameters: V1EditionsEditionIdArtefactsPostRequest): Promise<ArtefactDTO> {
        const response = await this.v1EditionsEditionIdArtefactsPostRaw(requestParameters);
        return await response.value();
    }

}
