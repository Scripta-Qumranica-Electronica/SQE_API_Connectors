/* tslint:disable */
/* eslint-disable */
/**
 * SQE API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ArtefactDataListDTO,
    ArtefactDataListDTOFromJSON,
    ArtefactDataListDTOToJSON,
    CreateTextFragmentDTO,
    CreateTextFragmentDTOFromJSON,
    CreateTextFragmentDTOToJSON,
    LineDataListDTO,
    LineDataListDTOFromJSON,
    LineDataListDTOToJSON,
    LineTextDTO,
    LineTextDTOFromJSON,
    LineTextDTOToJSON,
    TextEditionDTO,
    TextEditionDTOFromJSON,
    TextEditionDTOToJSON,
    TextFragmentDataDTO,
    TextFragmentDataDTOFromJSON,
    TextFragmentDataDTOToJSON,
    TextFragmentDataListDTO,
    TextFragmentDataListDTOFromJSON,
    TextFragmentDataListDTOToJSON,
    UpdateTextFragmentDTO,
    UpdateTextFragmentDTOFromJSON,
    UpdateTextFragmentDTOToJSON,
} from '../models';

export interface V1EditionsEditionIdLinesLineIdGetRequest {
    editionId: number;
    lineId: number;
}

export interface V1EditionsEditionIdTextFragmentsGetRequest {
    editionId: number;
}

export interface V1EditionsEditionIdTextFragmentsPostRequest {
    editionId: number;
    createTextFragmentDTO?: CreateTextFragmentDTO;
}

export interface V1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGetRequest {
    editionId: number;
    textFragmentId: number;
}

export interface V1EditionsEditionIdTextFragmentsTextFragmentIdGetRequest {
    editionId: number;
    textFragmentId: number;
}

export interface V1EditionsEditionIdTextFragmentsTextFragmentIdLinesGetRequest {
    editionId: number;
    textFragmentId: number;
}

export interface V1EditionsEditionIdTextFragmentsTextFragmentIdPutRequest {
    editionId: number;
    textFragmentId: number;
    updateTextFragmentDTO?: UpdateTextFragmentDTO;
}

/**
 * 
 */
export class TextApi extends runtime.BaseAPI {

    /**
     * Retrieves all signs and their data from the given line
     */
    async v1EditionsEditionIdLinesLineIdGetRaw(requestParameters: V1EditionsEditionIdLinesLineIdGetRequest): Promise<runtime.ApiResponse<LineTextDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdLinesLineIdGet.');
        }

        if (requestParameters.lineId === null || requestParameters.lineId === undefined) {
            throw new runtime.RequiredError('lineId','Required parameter requestParameters.lineId was null or undefined when calling v1EditionsEditionIdLinesLineIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/lines/{lineId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"lineId"}}`, encodeURIComponent(String(requestParameters.lineId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LineTextDTOFromJSON(jsonValue));
    }

    /**
     * Retrieves all signs and their data from the given line
     */
    async v1EditionsEditionIdLinesLineIdGet(requestParameters: V1EditionsEditionIdLinesLineIdGetRequest): Promise<LineTextDTO> {
        const response = await this.v1EditionsEditionIdLinesLineIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves the ids of all Fragments of all fragments in the given edition of a scroll
     */
    async v1EditionsEditionIdTextFragmentsGetRaw(requestParameters: V1EditionsEditionIdTextFragmentsGetRequest): Promise<runtime.ApiResponse<TextFragmentDataListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/text-fragments`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TextFragmentDataListDTOFromJSON(jsonValue));
    }

    /**
     * Retrieves the ids of all Fragments of all fragments in the given edition of a scroll
     */
    async v1EditionsEditionIdTextFragmentsGet(requestParameters: V1EditionsEditionIdTextFragmentsGetRequest): Promise<TextFragmentDataListDTO> {
        const response = await this.v1EditionsEditionIdTextFragmentsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new text fragment in the given edition of a scroll
     */
    async v1EditionsEditionIdTextFragmentsPostRaw(requestParameters: V1EditionsEditionIdTextFragmentsPostRequest): Promise<runtime.ApiResponse<TextFragmentDataDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/text-fragments`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTextFragmentDTOToJSON(requestParameters.createTextFragmentDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TextFragmentDataDTOFromJSON(jsonValue));
    }

    /**
     * Creates a new text fragment in the given edition of a scroll
     */
    async v1EditionsEditionIdTextFragmentsPost(requestParameters: V1EditionsEditionIdTextFragmentsPostRequest): Promise<TextFragmentDataDTO> {
        const response = await this.v1EditionsEditionIdTextFragmentsPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves the ids of all Artefacts in the given textFragmentName
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGetRaw(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGetRequest): Promise<runtime.ApiResponse<ArtefactDataListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet.');
        }

        if (requestParameters.textFragmentId === null || requestParameters.textFragmentId === undefined) {
            throw new runtime.RequiredError('textFragmentId','Required parameter requestParameters.textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/text-fragments/{textFragmentId}/artefacts`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"textFragmentId"}}`, encodeURIComponent(String(requestParameters.textFragmentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactDataListDTOFromJSON(jsonValue));
    }

    /**
     * Retrieves the ids of all Artefacts in the given textFragmentName
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGetRequest): Promise<ArtefactDataListDTO> {
        const response = await this.v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves all signs and their data from the given textFragmentName
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdGetRaw(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdGetRequest): Promise<runtime.ApiResponse<TextEditionDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdGet.');
        }

        if (requestParameters.textFragmentId === null || requestParameters.textFragmentId === undefined) {
            throw new runtime.RequiredError('textFragmentId','Required parameter requestParameters.textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/text-fragments/{textFragmentId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"textFragmentId"}}`, encodeURIComponent(String(requestParameters.textFragmentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TextEditionDTOFromJSON(jsonValue));
    }

    /**
     * Retrieves all signs and their data from the given textFragmentName
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdGet(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdGetRequest): Promise<TextEditionDTO> {
        const response = await this.v1EditionsEditionIdTextFragmentsTextFragmentIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves the ids of all lines in the given textFragmentName
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGetRaw(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdLinesGetRequest): Promise<runtime.ApiResponse<LineDataListDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet.');
        }

        if (requestParameters.textFragmentId === null || requestParameters.textFragmentId === undefined) {
            throw new runtime.RequiredError('textFragmentId','Required parameter requestParameters.textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/text-fragments/{textFragmentId}/lines`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"textFragmentId"}}`, encodeURIComponent(String(requestParameters.textFragmentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LineDataListDTOFromJSON(jsonValue));
    }

    /**
     * Retrieves the ids of all lines in the given textFragmentName
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdLinesGetRequest): Promise<LineDataListDTO> {
        const response = await this.v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates the specified text fragment with the submitted properties
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdPutRaw(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdPutRequest): Promise<runtime.ApiResponse<TextFragmentDataDTO>> {
        if (requestParameters.editionId === null || requestParameters.editionId === undefined) {
            throw new runtime.RequiredError('editionId','Required parameter requestParameters.editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdPut.');
        }

        if (requestParameters.textFragmentId === null || requestParameters.textFragmentId === undefined) {
            throw new runtime.RequiredError('textFragmentId','Required parameter requestParameters.textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/v1/editions/{editionId}/text-fragments/{textFragmentId}`.replace(`{${"editionId"}}`, encodeURIComponent(String(requestParameters.editionId))).replace(`{${"textFragmentId"}}`, encodeURIComponent(String(requestParameters.textFragmentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTextFragmentDTOToJSON(requestParameters.updateTextFragmentDTO),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TextFragmentDataDTOFromJSON(jsonValue));
    }

    /**
     * Updates the specified text fragment with the submitted properties
     */
    async v1EditionsEditionIdTextFragmentsTextFragmentIdPut(requestParameters: V1EditionsEditionIdTextFragmentsTextFragmentIdPutRequest): Promise<TextFragmentDataDTO> {
        const response = await this.v1EditionsEditionIdTextFragmentsTextFragmentIdPutRaw(requestParameters);
        return await response.value();
    }

}
