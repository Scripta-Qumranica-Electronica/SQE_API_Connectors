/* tslint:disable */
/* eslint-disable */
/**
 * SQE API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountActivationRequestDTO
 */
export interface AccountActivationRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountActivationRequestDTO
     */
    token: string;
}
/**
 * 
 * @export
 * @interface AdminEditorRequestDTO
 */
export interface AdminEditorRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminEditorRequestDTO
     */
    editorName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminEditorRequestDTO
     */
    editorEmail: string;
    /**
     * 
     * @type {number}
     * @memberof AdminEditorRequestDTO
     */
    editionId: number;
    /**
     * 
     * @type {string}
     * @memberof AdminEditorRequestDTO
     */
    editionName: string;
    /**
     * 
     * @type {string}
     * @memberof AdminEditorRequestDTO
     */
    date: string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminEditorRequestDTO
     */
    mayLock: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminEditorRequestDTO
     */
    mayRead: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminEditorRequestDTO
     */
    mayWrite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminEditorRequestDTO
     */
    isAdmin: boolean;
}
/**
 * 
 * @export
 * @interface AdminEditorRequestListDTO
 */
export interface AdminEditorRequestListDTO {
    /**
     * 
     * @type {Array<AdminEditorRequestDTO>}
     * @memberof AdminEditorRequestListDTO
     */
    editorRequests: Array<AdminEditorRequestDTO>;
}
/**
 * 
 * @export
 * @interface ArtefactDTO
 */
export interface ArtefactDTO {
    /**
     * 
     * @type {number}
     * @memberof ArtefactDTO
     */
    editionId: number;
    /**
     * 
     * @type {string}
     * @memberof ArtefactDTO
     */
    imagedObjectId: string;
    /**
     * 
     * @type {number}
     * @memberof ArtefactDTO
     */
    imageId: number;
    /**
     * 
     * @type {number}
     * @memberof ArtefactDTO
     */
    artefactDataEditorId: number;
    /**
     * 
     * @type {string}
     * @memberof ArtefactDTO
     */
    mask: string;
    /**
     * 
     * @type {number}
     * @memberof ArtefactDTO
     */
    artefactMaskEditorId: number;
    /**
     * 
     * @type {boolean}
     * @memberof ArtefactDTO
     */
    isPlaced: boolean;
    /**
     * 
     * @type {PlacementDTO}
     * @memberof ArtefactDTO
     */
    placement: PlacementDTO;
    /**
     * 
     * @type {number}
     * @memberof ArtefactDTO
     */
    artefactPlacementEditorId?: number | null;
    /**
     * 
     * @type {SideDesignation}
     * @memberof ArtefactDTO
     */
    side: SideDesignation;
    /**
     * 
     * @type {string}
     * @memberof ArtefactDTO
     */
    statusMessage?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ArtefactDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ArtefactDTO
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ArtefactDataDTO
 */
export interface ArtefactDataDTO {
    /**
     * 
     * @type {number}
     * @memberof ArtefactDataDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ArtefactDataDTO
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ArtefactDataListDTO
 */
export interface ArtefactDataListDTO {
    /**
     * 
     * @type {Array<ArtefactDataDTO>}
     * @memberof ArtefactDataListDTO
     */
    artefacts: Array<ArtefactDataDTO>;
}
/**
 * 
 * @export
 * @interface ArtefactGroupDTO
 */
export interface ArtefactGroupDTO {
    /**
     * 
     * @type {number}
     * @memberof ArtefactGroupDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ArtefactGroupDTO
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ArtefactGroupDTO
     */
    artefacts: Array<number>;
}
/**
 * 
 * @export
 * @interface ArtefactGroupListDTO
 */
export interface ArtefactGroupListDTO {
    /**
     * 
     * @type {Array<ArtefactGroupDTO>}
     * @memberof ArtefactGroupListDTO
     */
    artefactGroups: Array<ArtefactGroupDTO>;
}
/**
 * 
 * @export
 * @interface ArtefactListDTO
 */
export interface ArtefactListDTO {
    /**
     * 
     * @type {Array<ArtefactDTO>}
     * @memberof ArtefactListDTO
     */
    artefacts: Array<ArtefactDTO>;
}
/**
 * 
 * @export
 * @interface ArtefactTextFragmentMatchDTO
 */
export interface ArtefactTextFragmentMatchDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ArtefactTextFragmentMatchDTO
     */
    suggested: boolean;
    /**
     * 
     * @type {number}
     * @memberof ArtefactTextFragmentMatchDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ArtefactTextFragmentMatchDTO
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ArtefactTextFragmentMatchDTO
     */
    editorId: number;
}
/**
 * 
 * @export
 * @interface ArtefactTextFragmentMatchListDTO
 */
export interface ArtefactTextFragmentMatchListDTO {
    /**
     * 
     * @type {Array<ArtefactTextFragmentMatchDTO>}
     * @memberof ArtefactTextFragmentMatchListDTO
     */
    textFragments: Array<ArtefactTextFragmentMatchDTO>;
}
/**
 * 
 * @export
 * @interface AttributeDTO
 */
export interface AttributeDTO {
    /**
     * 
     * @type {number}
     * @memberof AttributeDTO
     */
    attributeId: number;
    /**
     * 
     * @type {string}
     * @memberof AttributeDTO
     */
    attributeName: string;
    /**
     * 
     * @type {Array<AttributeValueDTO>}
     * @memberof AttributeDTO
     */
    values: Array<AttributeValueDTO>;
    /**
     * 
     * @type {number}
     * @memberof AttributeDTO
     */
    creatorId: number;
    /**
     * 
     * @type {number}
     * @memberof AttributeDTO
     */
    editorId: number;
    /**
     * 
     * @type {string}
     * @memberof AttributeDTO
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDTO
     */
    editable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDTO
     */
    removable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDTO
     */
    repeatable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDTO
     */
    batchEditable?: boolean;
}
/**
 * 
 * @export
 * @interface AttributeListDTO
 */
export interface AttributeListDTO {
    /**
     * 
     * @type {Array<AttributeDTO>}
     * @memberof AttributeListDTO
     */
    attributes: Array<AttributeDTO>;
}
/**
 * 
 * @export
 * @interface AttributeValueDTO
 */
export interface AttributeValueDTO {
    /**
     * 
     * @type {number}
     * @memberof AttributeValueDTO
     */
    creatorId: number;
    /**
     * 
     * @type {number}
     * @memberof AttributeValueDTO
     */
    editorId: number;
    /**
     * 
     * @type {number}
     * @memberof AttributeValueDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof AttributeValueDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeValueDTO
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttributeValueDTO
     */
    cssDirectives?: string | null;
}
/**
 * 
 * @export
 * @interface BatchEditRoiDTO
 */
export interface BatchEditRoiDTO {
    /**
     * 
     * @type {Array<SetInterpretationRoiDTO>}
     * @memberof BatchEditRoiDTO
     */
    createRois?: Array<SetInterpretationRoiDTO> | null;
    /**
     * 
     * @type {Array<UpdateInterpretationRoiDTO>}
     * @memberof BatchEditRoiDTO
     */
    updateRois?: Array<UpdateInterpretationRoiDTO> | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof BatchEditRoiDTO
     */
    deleteRois?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface BatchEditRoiResponseDTO
 */
export interface BatchEditRoiResponseDTO {
    /**
     * 
     * @type {Array<InterpretationRoiDTO>}
     * @memberof BatchEditRoiResponseDTO
     */
    createRois: Array<InterpretationRoiDTO>;
    /**
     * 
     * @type {Array<UpdatedInterpretationRoiDTO>}
     * @memberof BatchEditRoiResponseDTO
     */
    updateRois: Array<UpdatedInterpretationRoiDTO>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BatchEditRoiResponseDTO
     */
    deleteRois: Array<number>;
}
/**
 * 
 * @export
 * @interface BatchUpdateArtefactPlacementDTO
 */
export interface BatchUpdateArtefactPlacementDTO {
    /**
     * 
     * @type {Array<UpdateArtefactPlacementDTO>}
     * @memberof BatchUpdateArtefactPlacementDTO
     */
    artefactPlacements: Array<UpdateArtefactPlacementDTO>;
}
/**
 * 
 * @export
 * @interface BatchUpdatedArtefactTransformDTO
 */
export interface BatchUpdatedArtefactTransformDTO {
    /**
     * 
     * @type {Array<UpdatedArtefactPlacementDTO>}
     * @memberof BatchUpdatedArtefactTransformDTO
     */
    artefactPlacements: Array<UpdatedArtefactPlacementDTO>;
}
/**
 * 
 * @export
 * @interface CatalogueMatchDTO
 */
export interface CatalogueMatchDTO {
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchDTO
     */
    imageCatalogId: number;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    institution: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    catalogueNumber1: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    catalogueNumber2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    proxy?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    filename: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    suffix: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    thumbnail: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    license: string;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchDTO
     */
    iaaEditionCatalogueId: number;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    manuscriptName: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    matchAuthor: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    matchConfirmationAuthor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchDTO
     */
    matchId: number;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    dateOfMatch: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    dateOfConfirmation?: string | null;
    /**
     * 
     * @type {SideDesignation}
     * @memberof CatalogueMatchDTO
     */
    catalogSide?: SideDesignation;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    imagedObjectId: string;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchDTO
     */
    manuscriptId: number;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    editionName: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    editionVolume: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    editionLocation1: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    editionLocation2: string;
    /**
     * 
     * @type {SideDesignation}
     * @memberof CatalogueMatchDTO
     */
    editionSide: SideDesignation;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchDTO
     */
    comment?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchDTO
     */
    textFragmentId: number;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchDTO
     */
    editionId: number;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogueMatchDTO
     */
    confirmed?: boolean | null;
}
/**
 * 
 * @export
 * @interface CatalogueMatchInputDTO
 */
export interface CatalogueMatchInputDTO {
    /**
     * 
     * @type {SideDesignation}
     * @memberof CatalogueMatchInputDTO
     */
    catalogSide?: SideDesignation;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchInputDTO
     */
    imagedObjectId: string;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchInputDTO
     */
    manuscriptId: number;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchInputDTO
     */
    editionName: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchInputDTO
     */
    editionVolume: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchInputDTO
     */
    editionLocation1: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchInputDTO
     */
    editionLocation2: string;
    /**
     * 
     * @type {SideDesignation}
     * @memberof CatalogueMatchInputDTO
     */
    editionSide: SideDesignation;
    /**
     * 
     * @type {string}
     * @memberof CatalogueMatchInputDTO
     */
    comment?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchInputDTO
     */
    textFragmentId: number;
    /**
     * 
     * @type {number}
     * @memberof CatalogueMatchInputDTO
     */
    editionId: number;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogueMatchInputDTO
     */
    confirmed?: boolean | null;
}
/**
 * 
 * @export
 * @interface CatalogueMatchListDTO
 */
export interface CatalogueMatchListDTO {
    /**
     * 
     * @type {Array<CatalogueMatchDTO>}
     * @memberof CatalogueMatchListDTO
     */
    matches: Array<CatalogueMatchDTO>;
}
/**
 * 
 * @export
 * @interface CharacterShapeDTO
 */
export interface CharacterShapeDTO {
    /**
     * 
     * @type {number}
     * @memberof CharacterShapeDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterShapeDTO
     */
    character: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterShapeDTO
     */
    polygon: string;
    /**
     * 
     * @type {string}
     * @memberof CharacterShapeDTO
     */
    imageURL: string;
    /**
     * 
     * @type {number}
     * @memberof CharacterShapeDTO
     */
    rotation?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CharacterShapeDTO
     */
    attributes: Array<string>;
}
/**
 * 
 * @export
 * @interface CommentaryCreateDTO
 */
export interface CommentaryCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof CommentaryCreateDTO
     */
    commentary?: string | null;
}
/**
 * 
 * @export
 * @interface CommentaryDTO
 */
export interface CommentaryDTO {
    /**
     * 
     * @type {number}
     * @memberof CommentaryDTO
     */
    creatorId: number;
    /**
     * 
     * @type {number}
     * @memberof CommentaryDTO
     */
    editorId: number;
    /**
     * 
     * @type {string}
     * @memberof CommentaryDTO
     */
    commentary?: string | null;
}
/**
 * 
 * @export
 * @interface CreateArtefactDTO
 */
export interface CreateArtefactDTO {
    /**
     * 
     * @type {number}
     * @memberof CreateArtefactDTO
     */
    masterImageId: number;
    /**
     * 
     * @type {string}
     * @memberof CreateArtefactDTO
     */
    mask: string;
    /**
     * 
     * @type {PlacementDTO}
     * @memberof CreateArtefactDTO
     */
    placement?: PlacementDTO | null;
    /**
     * 
     * @type {string}
     * @memberof CreateArtefactDTO
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateArtefactDTO
     */
    statusMessage?: string | null;
}
/**
 * 
 * @export
 * @interface CreateArtefactGroupDTO
 */
export interface CreateArtefactGroupDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateArtefactGroupDTO
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateArtefactGroupDTO
     */
    artefacts: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateAttributeDTO
 */
export interface CreateAttributeDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeDTO
     */
    attributeName: string;
    /**
     * 
     * @type {Array<CreateAttributeValueDTO>}
     * @memberof CreateAttributeDTO
     */
    values: Array<CreateAttributeValueDTO>;
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeDTO
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAttributeDTO
     */
    editable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAttributeDTO
     */
    removable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAttributeDTO
     */
    repeatable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAttributeDTO
     */
    batchEditable?: boolean;
}
/**
 * 
 * @export
 * @interface CreateAttributeValueDTO
 */
export interface CreateAttributeValueDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeValueDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeValueDTO
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeValueDTO
     */
    cssDirectives?: string | null;
}
/**
 * 
 * @export
 * @interface CreateTextFragmentDTO
 */
export interface CreateTextFragmentDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateTextFragmentDTO
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTextFragmentDTO
     */
    previousTextFragmentId?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateTextFragmentDTO
     */
    nextTextFragmentId?: number | null;
}
/**
 * 
 * @export
 * @interface DeleteDTO
 */
export interface DeleteDTO {
    /**
     * 
     * @type {EditionEntities}
     * @memberof DeleteDTO
     */
    entity: EditionEntities;
    /**
     * 
     * @type {Array<number>}
     * @memberof DeleteDTO
     */
    ids: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteTokenDTO
 */
export interface DeleteTokenDTO {
    /**
     * 
     * @type {number}
     * @memberof DeleteTokenDTO
     */
    editionId: number;
    /**
     * 
     * @type {string}
     * @memberof DeleteTokenDTO
     */
    token: string;
}
/**
 * 
 * @export
 * @interface DetailedEditorRightsDTO
 */
export interface DetailedEditorRightsDTO {
    /**
     * 
     * @type {string}
     * @memberof DetailedEditorRightsDTO
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof DetailedEditorRightsDTO
     */
    editionId: number;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedEditorRightsDTO
     */
    mayLock: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedEditorRightsDTO
     */
    mayRead: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedEditorRightsDTO
     */
    mayWrite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedEditorRightsDTO
     */
    isAdmin: boolean;
}
/**
 * 
 * @export
 * @interface DetailedUserDTO
 */
export interface DetailedUserDTO {
    /**
     * 
     * @type {string}
     * @memberof DetailedUserDTO
     */
    forename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailedUserDTO
     */
    surname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailedUserDTO
     */
    organization?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedUserDTO
     */
    activated: boolean;
    /**
     * 
     * @type {number}
     * @memberof DetailedUserDTO
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof DetailedUserDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface DetailedUserTokenDTO
 */
export interface DetailedUserTokenDTO {
    /**
     * 
     * @type {string}
     * @memberof DetailedUserTokenDTO
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof DetailedUserTokenDTO
     */
    forename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailedUserTokenDTO
     */
    surname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DetailedUserTokenDTO
     */
    organization?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DetailedUserTokenDTO
     */
    activated: boolean;
    /**
     * 
     * @type {number}
     * @memberof DetailedUserTokenDTO
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof DetailedUserTokenDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Direction {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2
}

/**
 * 
 * @export
 * @interface EditionCopyDTO
 */
export interface EditionCopyDTO {
    /**
     * 
     * @type {string}
     * @memberof EditionCopyDTO
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditionCopyDTO
     */
    copyrightHolder?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditionCopyDTO
     */
    collaborators?: string | null;
}
/**
 * 
 * @export
 * @interface EditionDTO
 */
export interface EditionDTO {
    /**
     * 
     * @type {number}
     * @memberof EditionDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof EditionDTO
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof EditionDTO
     */
    editionDataEditorId: number;
    /**
     * 
     * @type {PermissionDTO}
     * @memberof EditionDTO
     */
    permission: PermissionDTO;
    /**
     * 
     * @type {UserDTO}
     * @memberof EditionDTO
     */
    owner: UserDTO;
    /**
     * 
     * @type {string}
     * @memberof EditionDTO
     */
    thumbnailUrl?: string | null;
    /**
     * 
     * @type {Array<DetailedEditorRightsDTO>}
     * @memberof EditionDTO
     */
    shares: Array<DetailedEditorRightsDTO>;
    /**
     * 
     * @type {EditionManuscriptMetricsDTO}
     * @memberof EditionDTO
     */
    metrics: EditionManuscriptMetricsDTO;
    /**
     * 
     * @type {boolean}
     * @memberof EditionDTO
     */
    locked: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditionDTO
     */
    isPublic: boolean;
    /**
     * 
     * @type {string}
     * @memberof EditionDTO
     */
    lastEdit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditionDTO
     */
    copyright: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EditionEntities {
    Edition = 'edition',
    Artefact = 'artefact',
    ArtefactGroup = 'artefactGroup',
    Attribute = 'attribute',
    TextFragment = 'textFragment',
    Line = 'line',
    SignInterpretation = 'signInterpretation',
    Roi = 'roi'
}

/**
 * 
 * @export
 * @interface EditionGroupDTO
 */
export interface EditionGroupDTO {
    /**
     * 
     * @type {EditionDTO}
     * @memberof EditionGroupDTO
     */
    primary: EditionDTO;
    /**
     * 
     * @type {Array<EditionDTO>}
     * @memberof EditionGroupDTO
     */
    others: Array<EditionDTO>;
}
/**
 * 
 * @export
 * @interface EditionListDTO
 */
export interface EditionListDTO {
    /**
     * 
     * @type {Array<Array<EditionDTO>>}
     * @memberof EditionListDTO
     */
    editions: Array<Array<EditionDTO>>;
}
/**
 * 
 * @export
 * @interface EditionManuscriptMetricsDTO
 */
export interface EditionManuscriptMetricsDTO {
    /**
     * 
     * @type {number}
     * @memberof EditionManuscriptMetricsDTO
     */
    ppi: number;
    /**
     * 
     * @type {number}
     * @memberof EditionManuscriptMetricsDTO
     */
    editorId: number;
    /**
     * 
     * @type {number}
     * @memberof EditionManuscriptMetricsDTO
     */
    width: number;
    /**
     * 
     * @type {number}
     * @memberof EditionManuscriptMetricsDTO
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof EditionManuscriptMetricsDTO
     */
    xOrigin: number;
    /**
     * 
     * @type {number}
     * @memberof EditionManuscriptMetricsDTO
     */
    yOrigin: number;
}
/**
 * 
 * @export
 * @interface EditionScriptCollectionDTO
 */
export interface EditionScriptCollectionDTO {
    /**
     * 
     * @type {Array<CharacterShapeDTO>}
     * @memberof EditionScriptCollectionDTO
     */
    letters: Array<CharacterShapeDTO>;
}
/**
 * 
 * @export
 * @interface EditionScriptLinesDTO
 */
export interface EditionScriptLinesDTO {
    /**
     * 
     * @type {Array<ScriptTextFragmentDTO>}
     * @memberof EditionScriptLinesDTO
     */
    textFragments: Array<ScriptTextFragmentDTO>;
}
/**
 * 
 * @export
 * @interface EditionUpdateRequestDTO
 */
export interface EditionUpdateRequestDTO {
    /**
     * 
     * @type {UpdateEditionManuscriptMetricsDTO}
     * @memberof EditionUpdateRequestDTO
     */
    metrics?: UpdateEditionManuscriptMetricsDTO | null;
    /**
     * 
     * @type {string}
     * @memberof EditionUpdateRequestDTO
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditionUpdateRequestDTO
     */
    copyrightHolder?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditionUpdateRequestDTO
     */
    collaborators?: string | null;
}
/**
 * 
 * @export
 * @interface EditorDTO
 */
export interface EditorDTO {
    /**
     * 
     * @type {string}
     * @memberof EditorDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof EditorDTO
     */
    forename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditorDTO
     */
    surname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EditorDTO
     */
    organization?: string | null;
}
/**
 * 
 * @export
 * @interface EditorInvitationDTO
 */
export interface EditorInvitationDTO {
    /**
     * 
     * @type {string}
     * @memberof EditorInvitationDTO
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof EditorInvitationDTO
     */
    requestingAdminName: string;
    /**
     * 
     * @type {string}
     * @memberof EditorInvitationDTO
     */
    requestingAdminEmail: string;
    /**
     * 
     * @type {number}
     * @memberof EditorInvitationDTO
     */
    editionId: number;
    /**
     * 
     * @type {string}
     * @memberof EditorInvitationDTO
     */
    editionName: string;
    /**
     * 
     * @type {string}
     * @memberof EditorInvitationDTO
     */
    date: string;
    /**
     * 
     * @type {boolean}
     * @memberof EditorInvitationDTO
     */
    mayLock: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditorInvitationDTO
     */
    mayRead: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditorInvitationDTO
     */
    mayWrite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditorInvitationDTO
     */
    isAdmin: boolean;
}
/**
 * 
 * @export
 * @interface EditorInvitationListDTO
 */
export interface EditorInvitationListDTO {
    /**
     * 
     * @type {Array<EditorInvitationDTO>}
     * @memberof EditorInvitationListDTO
     */
    editorInvitations: Array<EditorInvitationDTO>;
}
/**
 * 
 * @export
 * @interface ImageDTO
 */
export interface ImageDTO {
    /**
     * 
     * @type {number}
     * @memberof ImageDTO
     */
    imageToImageMapEditorId?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ImageDTO
     */
    regionInMasterImage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageDTO
     */
    regionInImage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageDTO
     */
    transformToMaster?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ImageDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ImageDTO
     */
    url: string;
    /**
     * 
     * @type {Lighting}
     * @memberof ImageDTO
     */
    lightingType: Lighting;
    /**
     * 
     * @type {Direction}
     * @memberof ImageDTO
     */
    lightingDirection: Direction;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageDTO
     */
    waveLength: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ImageDTO
     */
    type: string;
    /**
     * 
     * @type {SideDesignation}
     * @memberof ImageDTO
     */
    side: SideDesignation;
    /**
     * 
     * @type {number}
     * @memberof ImageDTO
     */
    ppi: number;
    /**
     * 
     * @type {boolean}
     * @memberof ImageDTO
     */
    master: boolean;
    /**
     * 
     * @type {number}
     * @memberof ImageDTO
     */
    catalogNumber: number;
}
/**
 * 
 * @export
 * @interface ImageInstitutionDTO
 */
export interface ImageInstitutionDTO {
    /**
     * 
     * @type {string}
     * @memberof ImageInstitutionDTO
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ImageInstitutionListDTO
 */
export interface ImageInstitutionListDTO {
    /**
     * 
     * @type {Array<ImageInstitutionDTO>}
     * @memberof ImageInstitutionListDTO
     */
    institutions: Array<ImageInstitutionDTO>;
}
/**
 * 
 * @export
 * @interface ImageStackDTO
 */
export interface ImageStackDTO {
    /**
     * 
     * @type {number}
     * @memberof ImageStackDTO
     */
    id?: number | null;
    /**
     * 
     * @type {Array<ImageDTO>}
     * @memberof ImageStackDTO
     */
    images: Array<ImageDTO>;
    /**
     * 
     * @type {number}
     * @memberof ImageStackDTO
     */
    masterIndex?: number | null;
}
/**
 * 
 * @export
 * @interface ImagedObjectDTO
 */
export interface ImagedObjectDTO {
    /**
     * 
     * @type {string}
     * @memberof ImagedObjectDTO
     */
    id: string;
    /**
     * 
     * @type {ImageStackDTO}
     * @memberof ImagedObjectDTO
     */
    recto: ImageStackDTO;
    /**
     * 
     * @type {ImageStackDTO}
     * @memberof ImagedObjectDTO
     */
    verso: ImageStackDTO;
    /**
     * 
     * @type {Array<ArtefactDTO>}
     * @memberof ImagedObjectDTO
     */
    artefacts: Array<ArtefactDTO>;
}
/**
 * 
 * @export
 * @interface ImagedObjectListDTO
 */
export interface ImagedObjectListDTO {
    /**
     * 
     * @type {Array<ImagedObjectDTO>}
     * @memberof ImagedObjectListDTO
     */
    imagedObjects: Array<ImagedObjectDTO>;
}
/**
 * 
 * @export
 * @interface ImagedObjectTextFragmentMatchDTO
 */
export interface ImagedObjectTextFragmentMatchDTO {
    /**
     * 
     * @type {number}
     * @memberof ImagedObjectTextFragmentMatchDTO
     */
    editionId: number;
    /**
     * 
     * @type {string}
     * @memberof ImagedObjectTextFragmentMatchDTO
     */
    manuscriptName: string;
    /**
     * 
     * @type {number}
     * @memberof ImagedObjectTextFragmentMatchDTO
     */
    textFragmentId: number;
    /**
     * 
     * @type {string}
     * @memberof ImagedObjectTextFragmentMatchDTO
     */
    textFragmentName: string;
    /**
     * 
     * @type {SideDesignation}
     * @memberof ImagedObjectTextFragmentMatchDTO
     */
    side: SideDesignation;
}
/**
 * 
 * @export
 * @interface ImagedObjectTextFragmentMatchListDTO
 */
export interface ImagedObjectTextFragmentMatchListDTO {
    /**
     * 
     * @type {Array<ImagedObjectTextFragmentMatchDTO>}
     * @memberof ImagedObjectTextFragmentMatchListDTO
     */
    matches?: Array<ImagedObjectTextFragmentMatchDTO> | null;
}
/**
 * 
 * @export
 * @interface InstitutionalImageDTO
 */
export interface InstitutionalImageDTO {
    /**
     * 
     * @type {string}
     * @memberof InstitutionalImageDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof InstitutionalImageDTO
     */
    thumbnailUrl: string;
    /**
     * 
     * @type {string}
     * @memberof InstitutionalImageDTO
     */
    license: string;
}
/**
 * 
 * @export
 * @interface InstitutionalImageListDTO
 */
export interface InstitutionalImageListDTO {
    /**
     * 
     * @type {Array<InstitutionalImageDTO>}
     * @memberof InstitutionalImageListDTO
     */
    institutionalImages: Array<InstitutionalImageDTO>;
}
/**
 * 
 * @export
 * @interface InterpretationAttributeCreateDTO
 */
export interface InterpretationAttributeCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof InterpretationAttributeCreateDTO
     */
    commentary?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeCreateDTO
     */
    sequence?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeCreateDTO
     */
    attributeId: number;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeCreateDTO
     */
    attributeValueId: number;
}
/**
 * 
 * @export
 * @interface InterpretationAttributeDTO
 */
export interface InterpretationAttributeDTO {
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeDTO
     */
    interpretationAttributeId: number;
    /**
     * 
     * @type {string}
     * @memberof InterpretationAttributeDTO
     */
    attributeString: string;
    /**
     * 
     * @type {string}
     * @memberof InterpretationAttributeDTO
     */
    attributeValueString: string;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeDTO
     */
    creatorId: number;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeDTO
     */
    editorId: number;
    /**
     * 
     * @type {CommentaryDTO}
     * @memberof InterpretationAttributeDTO
     */
    commentary?: CommentaryDTO | null;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeDTO
     */
    sequence?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeDTO
     */
    attributeId: number;
    /**
     * 
     * @type {number}
     * @memberof InterpretationAttributeDTO
     */
    attributeValueId: number;
}
/**
 * 
 * @export
 * @interface InterpretationRoiDTO
 */
export interface InterpretationRoiDTO {
    /**
     * 
     * @type {number}
     * @memberof InterpretationRoiDTO
     */
    creatorId: number;
    /**
     * 
     * @type {number}
     * @memberof InterpretationRoiDTO
     */
    editorId: number;
    /**
     * 
     * @type {number}
     * @memberof InterpretationRoiDTO
     */
    interpretationRoiId: number;
    /**
     * 
     * @type {number}
     * @memberof InterpretationRoiDTO
     */
    artefactId: number;
    /**
     * 
     * @type {number}
     * @memberof InterpretationRoiDTO
     */
    signInterpretationId: number;
    /**
     * 
     * @type {string}
     * @memberof InterpretationRoiDTO
     */
    shape: string;
    /**
     * 
     * @type {TranslateDTO}
     * @memberof InterpretationRoiDTO
     */
    translate: TranslateDTO;
    /**
     * 
     * @type {number}
     * @memberof InterpretationRoiDTO
     */
    stanceRotation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InterpretationRoiDTO
     */
    exceptional: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InterpretationRoiDTO
     */
    valuesSet: boolean;
}
/**
 * 
 * @export
 * @interface InterpretationRoiDTOList
 */
export interface InterpretationRoiDTOList {
    /**
     * 
     * @type {Array<InterpretationRoiDTO>}
     * @memberof InterpretationRoiDTOList
     */
    rois: Array<InterpretationRoiDTO>;
}
/**
 * 
 * @export
 * @interface InviteEditorDTO
 */
export interface InviteEditorDTO {
    /**
     * 
     * @type {string}
     * @memberof InviteEditorDTO
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof InviteEditorDTO
     */
    mayLock: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InviteEditorDTO
     */
    mayRead: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InviteEditorDTO
     */
    mayWrite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InviteEditorDTO
     */
    isAdmin: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Lighting {
    NUMBER_0 = 0,
    NUMBER_1 = 1
}

/**
 * 
 * @export
 * @interface LineDTO
 */
export interface LineDTO {
    /**
     * 
     * @type {number}
     * @memberof LineDTO
     */
    lineId: number;
    /**
     * 
     * @type {string}
     * @memberof LineDTO
     */
    lineName: string;
    /**
     * 
     * @type {number}
     * @memberof LineDTO
     */
    editorId: number;
    /**
     * 
     * @type {Array<SignDTO>}
     * @memberof LineDTO
     */
    signs: Array<SignDTO>;
}
/**
 * 
 * @export
 * @interface LineDataDTO
 */
export interface LineDataDTO {
    /**
     * 
     * @type {number}
     * @memberof LineDataDTO
     */
    lineId: number;
    /**
     * 
     * @type {string}
     * @memberof LineDataDTO
     */
    lineName: string;
}
/**
 * 
 * @export
 * @interface LineDataListDTO
 */
export interface LineDataListDTO {
    /**
     * 
     * @type {Array<LineDataDTO>}
     * @memberof LineDataListDTO
     */
    lines: Array<LineDataDTO>;
}
/**
 * 
 * @export
 * @interface LineTextDTO
 */
export interface LineTextDTO {
    /**
     * 
     * @type {string}
     * @memberof LineTextDTO
     */
    licence: string;
    /**
     * 
     * @type {{ [key: string]: EditorDTO; }}
     * @memberof LineTextDTO
     */
    editors: { [key: string]: EditorDTO; };
    /**
     * 
     * @type {number}
     * @memberof LineTextDTO
     */
    lineId: number;
    /**
     * 
     * @type {string}
     * @memberof LineTextDTO
     */
    lineName: string;
    /**
     * 
     * @type {number}
     * @memberof LineTextDTO
     */
    editorId: number;
    /**
     * 
     * @type {Array<SignDTO>}
     * @memberof LineTextDTO
     */
    signs: Array<SignDTO>;
}
/**
 * 
 * @export
 * @interface LoginRequestDTO
 */
export interface LoginRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof LoginRequestDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequestDTO
     */
    password: string;
}
/**
 * 
 * @export
 * @interface NewUserRequestDTO
 */
export interface NewUserRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof NewUserRequestDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequestDTO
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequestDTO
     */
    organization?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequestDTO
     */
    forename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequestDTO
     */
    surname?: string | null;
}
/**
 * 
 * @export
 * @interface NextSignInterpretationDTO
 */
export interface NextSignInterpretationDTO {
    /**
     * 
     * @type {number}
     * @memberof NextSignInterpretationDTO
     */
    nextSignInterpretationId: number;
    /**
     * 
     * @type {number}
     * @memberof NextSignInterpretationDTO
     */
    creatorId: number;
    /**
     * 
     * @type {number}
     * @memberof NextSignInterpretationDTO
     */
    editorId: number;
}
/**
 * 
 * @export
 * @interface PermissionDTO
 */
export interface PermissionDTO {
    /**
     * 
     * @type {boolean}
     * @memberof PermissionDTO
     */
    mayRead: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionDTO
     */
    mayWrite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionDTO
     */
    isAdmin: boolean;
}
/**
 * 
 * @export
 * @interface PlacementDTO
 */
export interface PlacementDTO {
    /**
     * 
     * @type {number}
     * @memberof PlacementDTO
     */
    scale: number;
    /**
     * 
     * @type {number}
     * @memberof PlacementDTO
     */
    rotate: number;
    /**
     * 
     * @type {number}
     * @memberof PlacementDTO
     */
    zIndex: number;
    /**
     * 
     * @type {TranslateDTO}
     * @memberof PlacementDTO
     */
    translate?: TranslateDTO | null;
}
/**
 * 
 * @export
 * @interface ResendUserAccountActivationRequestDTO
 */
export interface ResendUserAccountActivationRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ResendUserAccountActivationRequestDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface ResetForgottenUserPasswordRequestDTO
 */
export interface ResetForgottenUserPasswordRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ResetForgottenUserPasswordRequestDTO
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof ResetForgottenUserPasswordRequestDTO
     */
    token: string;
}
/**
 * 
 * @export
 * @interface ResetLoggedInUserPasswordRequestDTO
 */
export interface ResetLoggedInUserPasswordRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ResetLoggedInUserPasswordRequestDTO
     */
    oldPassword: string;
    /**
     * 
     * @type {string}
     * @memberof ResetLoggedInUserPasswordRequestDTO
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface ResetUserPasswordRequestDTO
 */
export interface ResetUserPasswordRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ResetUserPasswordRequestDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface ScriptArtefactCharactersDTO
 */
export interface ScriptArtefactCharactersDTO {
    /**
     * 
     * @type {string}
     * @memberof ScriptArtefactCharactersDTO
     */
    artefactName: string;
    /**
     * 
     * @type {number}
     * @memberof ScriptArtefactCharactersDTO
     */
    artefactId: number;
    /**
     * 
     * @type {PlacementDTO}
     * @memberof ScriptArtefactCharactersDTO
     */
    placement: PlacementDTO;
    /**
     * 
     * @type {Array<SignInterpretationDTO>}
     * @memberof ScriptArtefactCharactersDTO
     */
    characters: Array<SignInterpretationDTO>;
}
/**
 * 
 * @export
 * @interface ScriptLineDTO
 */
export interface ScriptLineDTO {
    /**
     * 
     * @type {string}
     * @memberof ScriptLineDTO
     */
    lineName: string;
    /**
     * 
     * @type {number}
     * @memberof ScriptLineDTO
     */
    lineId: number;
    /**
     * 
     * @type {Array<ScriptArtefactCharactersDTO>}
     * @memberof ScriptLineDTO
     */
    artefacts: Array<ScriptArtefactCharactersDTO>;
}
/**
 * 
 * @export
 * @interface ScriptTextFragmentDTO
 */
export interface ScriptTextFragmentDTO {
    /**
     * 
     * @type {string}
     * @memberof ScriptTextFragmentDTO
     */
    textFragmentName: string;
    /**
     * 
     * @type {number}
     * @memberof ScriptTextFragmentDTO
     */
    textFragmentId: number;
    /**
     * 
     * @type {Array<ScriptLineDTO>}
     * @memberof ScriptTextFragmentDTO
     */
    lines: Array<ScriptLineDTO>;
}
/**
 * 
 * @export
 * @interface SetInterpretationRoiDTO
 */
export interface SetInterpretationRoiDTO {
    /**
     * 
     * @type {number}
     * @memberof SetInterpretationRoiDTO
     */
    artefactId: number;
    /**
     * 
     * @type {number}
     * @memberof SetInterpretationRoiDTO
     */
    signInterpretationId: number;
    /**
     * 
     * @type {string}
     * @memberof SetInterpretationRoiDTO
     */
    shape: string;
    /**
     * 
     * @type {TranslateDTO}
     * @memberof SetInterpretationRoiDTO
     */
    translate: TranslateDTO;
    /**
     * 
     * @type {number}
     * @memberof SetInterpretationRoiDTO
     */
    stanceRotation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SetInterpretationRoiDTO
     */
    exceptional: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SetInterpretationRoiDTO
     */
    valuesSet: boolean;
}
/**
 * 
 * @export
 * @interface SetInterpretationRoiDTOList
 */
export interface SetInterpretationRoiDTOList {
    /**
     * 
     * @type {Array<SetInterpretationRoiDTO>}
     * @memberof SetInterpretationRoiDTOList
     */
    rois: Array<SetInterpretationRoiDTO>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SideDesignation {
    NUMBER_0 = 0,
    NUMBER_1 = 1
}

/**
 * 
 * @export
 * @interface SignDTO
 */
export interface SignDTO {
    /**
     * 
     * @type {Array<SignInterpretationDTO>}
     * @memberof SignDTO
     */
    signInterpretations: Array<SignInterpretationDTO>;
}
/**
 * 
 * @export
 * @interface SignInterpretationCreateDTO
 */
export interface SignInterpretationCreateDTO {
    /**
     * 
     * @type {number}
     * @memberof SignInterpretationCreateDTO
     */
    lineId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof SignInterpretationCreateDTO
     */
    previousSignInterpretationIds?: Array<number> | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof SignInterpretationCreateDTO
     */
    nextSignInterpretationIds?: Array<number> | null;
    /**
     * 
     * @type {Array<InterpretationAttributeCreateDTO>}
     * @memberof SignInterpretationCreateDTO
     */
    attributes: Array<InterpretationAttributeCreateDTO>;
    /**
     * 
     * @type {Array<SetInterpretationRoiDTO>}
     * @memberof SignInterpretationCreateDTO
     */
    rois: Array<SetInterpretationRoiDTO>;
    /**
     * 
     * @type {CommentaryCreateDTO}
     * @memberof SignInterpretationCreateDTO
     */
    commentary?: CommentaryCreateDTO | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignInterpretationCreateDTO
     */
    breakPreviousAndNextSignInterpretations?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SignInterpretationCreateDTO
     */
    character?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignInterpretationCreateDTO
     */
    isVariant: boolean;
}
/**
 * 
 * @export
 * @interface SignInterpretationDTO
 */
export interface SignInterpretationDTO {
    /**
     * 
     * @type {number}
     * @memberof SignInterpretationDTO
     */
    signInterpretationId: number;
    /**
     * 
     * @type {Array<NextSignInterpretationDTO>}
     * @memberof SignInterpretationDTO
     */
    nextSignInterpretations: Array<NextSignInterpretationDTO>;
    /**
     * 
     * @type {Array<InterpretationAttributeDTO>}
     * @memberof SignInterpretationDTO
     */
    attributes: Array<InterpretationAttributeDTO>;
    /**
     * 
     * @type {Array<InterpretationRoiDTO>}
     * @memberof SignInterpretationDTO
     */
    rois: Array<InterpretationRoiDTO>;
    /**
     * 
     * @type {CommentaryDTO}
     * @memberof SignInterpretationDTO
     */
    commentary?: CommentaryDTO | null;
    /**
     * 
     * @type {string}
     * @memberof SignInterpretationDTO
     */
    character?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SignInterpretationDTO
     */
    isVariant: boolean;
}
/**
 * 
 * @export
 * @interface SignInterpretationListDTO
 */
export interface SignInterpretationListDTO {
    /**
     * 
     * @type {Array<SignInterpretationDTO>}
     * @memberof SignInterpretationListDTO
     */
    signInterpretations?: Array<SignInterpretationDTO> | null;
}
/**
 * 
 * @export
 * @interface SimpleImageDTO
 */
export interface SimpleImageDTO {
    /**
     * 
     * @type {number}
     * @memberof SimpleImageDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleImageDTO
     */
    url: string;
    /**
     * 
     * @type {Lighting}
     * @memberof SimpleImageDTO
     */
    lightingType: Lighting;
    /**
     * 
     * @type {Direction}
     * @memberof SimpleImageDTO
     */
    lightingDirection: Direction;
    /**
     * 
     * @type {Array<string>}
     * @memberof SimpleImageDTO
     */
    waveLength: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SimpleImageDTO
     */
    type: string;
    /**
     * 
     * @type {SideDesignation}
     * @memberof SimpleImageDTO
     */
    side: SideDesignation;
    /**
     * 
     * @type {number}
     * @memberof SimpleImageDTO
     */
    ppi: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleImageDTO
     */
    master: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimpleImageDTO
     */
    catalogNumber: number;
}
/**
 * 
 * @export
 * @interface SimpleImageListDTO
 */
export interface SimpleImageListDTO {
    /**
     * 
     * @type {Array<SimpleImageDTO>}
     * @memberof SimpleImageListDTO
     */
    images: Array<SimpleImageDTO>;
}
/**
 * 
 * @export
 * @interface TextEditionDTO
 */
export interface TextEditionDTO {
    /**
     * 
     * @type {number}
     * @memberof TextEditionDTO
     */
    manuscriptId: number;
    /**
     * 
     * @type {string}
     * @memberof TextEditionDTO
     */
    editionName: string;
    /**
     * 
     * @type {number}
     * @memberof TextEditionDTO
     */
    editorId: number;
    /**
     * 
     * @type {string}
     * @memberof TextEditionDTO
     */
    licence: string;
    /**
     * 
     * @type {{ [key: string]: EditorDTO; }}
     * @memberof TextEditionDTO
     */
    editors: { [key: string]: EditorDTO; };
    /**
     * 
     * @type {Array<TextFragmentDTO>}
     * @memberof TextEditionDTO
     */
    textFragments: Array<TextFragmentDTO>;
}
/**
 * 
 * @export
 * @interface TextFragmentDTO
 */
export interface TextFragmentDTO {
    /**
     * 
     * @type {number}
     * @memberof TextFragmentDTO
     */
    textFragmentId: number;
    /**
     * 
     * @type {string}
     * @memberof TextFragmentDTO
     */
    textFragmentName: string;
    /**
     * 
     * @type {number}
     * @memberof TextFragmentDTO
     */
    editorId: number;
    /**
     * 
     * @type {Array<LineDTO>}
     * @memberof TextFragmentDTO
     */
    lines: Array<LineDTO>;
}
/**
 * 
 * @export
 * @interface TextFragmentDataDTO
 */
export interface TextFragmentDataDTO {
    /**
     * 
     * @type {number}
     * @memberof TextFragmentDataDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof TextFragmentDataDTO
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof TextFragmentDataDTO
     */
    editorId: number;
}
/**
 * 
 * @export
 * @interface TextFragmentDataListDTO
 */
export interface TextFragmentDataListDTO {
    /**
     * 
     * @type {Array<TextFragmentDataDTO>}
     * @memberof TextFragmentDataListDTO
     */
    textFragments: Array<TextFragmentDataDTO>;
}
/**
 * 
 * @export
 * @interface TranslateDTO
 */
export interface TranslateDTO {
    /**
     * 
     * @type {number}
     * @memberof TranslateDTO
     */
    x: number;
    /**
     * 
     * @type {number}
     * @memberof TranslateDTO
     */
    y: number;
}
/**
 * 
 * @export
 * @interface UnactivatedEmailUpdateRequestDTO
 */
export interface UnactivatedEmailUpdateRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UnactivatedEmailUpdateRequestDTO
     */
    newEmail: string;
    /**
     * 
     * @type {string}
     * @memberof UnactivatedEmailUpdateRequestDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface UpdateArtefactDTO
 */
export interface UpdateArtefactDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateArtefactDTO
     */
    mask?: string | null;
    /**
     * 
     * @type {PlacementDTO}
     * @memberof UpdateArtefactDTO
     */
    placement?: PlacementDTO | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateArtefactDTO
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateArtefactDTO
     */
    statusMessage?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateArtefactGroupDTO
 */
export interface UpdateArtefactGroupDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateArtefactGroupDTO
     */
    name?: string | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateArtefactGroupDTO
     */
    artefacts: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateArtefactPlacementDTO
 */
export interface UpdateArtefactPlacementDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateArtefactPlacementDTO
     */
    artefactId: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateArtefactPlacementDTO
     */
    isPlaced: boolean;
    /**
     * 
     * @type {PlacementDTO}
     * @memberof UpdateArtefactPlacementDTO
     */
    placement?: PlacementDTO | null;
}
/**
 * 
 * @export
 * @interface UpdateAttributeDTO
 */
export interface UpdateAttributeDTO {
    /**
     * 
     * @type {Array<CreateAttributeValueDTO>}
     * @memberof UpdateAttributeDTO
     */
    createValues: Array<CreateAttributeValueDTO>;
    /**
     * 
     * @type {Array<UpdateAttributeValueDTO>}
     * @memberof UpdateAttributeDTO
     */
    updateValues: Array<UpdateAttributeValueDTO>;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateAttributeDTO
     */
    deleteValues: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAttributeDTO
     */
    editable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAttributeDTO
     */
    removable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAttributeDTO
     */
    repeatable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAttributeDTO
     */
    batchEditable?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateAttributeValueDTO
 */
export interface UpdateAttributeValueDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateAttributeValueDTO
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateAttributeValueDTO
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAttributeValueDTO
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateAttributeValueDTO
     */
    cssDirectives?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateEditionManuscriptMetricsDTO
 */
export interface UpdateEditionManuscriptMetricsDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateEditionManuscriptMetricsDTO
     */
    width: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateEditionManuscriptMetricsDTO
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateEditionManuscriptMetricsDTO
     */
    xOrigin: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateEditionManuscriptMetricsDTO
     */
    yOrigin: number;
}
/**
 * 
 * @export
 * @interface UpdateEditorRightsDTO
 */
export interface UpdateEditorRightsDTO {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEditorRightsDTO
     */
    mayLock: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEditorRightsDTO
     */
    mayRead: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEditorRightsDTO
     */
    mayWrite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEditorRightsDTO
     */
    isAdmin: boolean;
}
/**
 * 
 * @export
 * @interface UpdateInterpretationRoiDTO
 */
export interface UpdateInterpretationRoiDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateInterpretationRoiDTO
     */
    interpretationRoiId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateInterpretationRoiDTO
     */
    artefactId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateInterpretationRoiDTO
     */
    signInterpretationId: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateInterpretationRoiDTO
     */
    shape: string;
    /**
     * 
     * @type {TranslateDTO}
     * @memberof UpdateInterpretationRoiDTO
     */
    translate: TranslateDTO;
    /**
     * 
     * @type {number}
     * @memberof UpdateInterpretationRoiDTO
     */
    stanceRotation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateInterpretationRoiDTO
     */
    exceptional: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateInterpretationRoiDTO
     */
    valuesSet: boolean;
}
/**
 * 
 * @export
 * @interface UpdateInterpretationRoiDTOList
 */
export interface UpdateInterpretationRoiDTOList {
    /**
     * 
     * @type {Array<UpdateInterpretationRoiDTO>}
     * @memberof UpdateInterpretationRoiDTOList
     */
    rois: Array<UpdateInterpretationRoiDTO>;
}
/**
 * 
 * @export
 * @interface UpdateTextFragmentDTO
 */
export interface UpdateTextFragmentDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateTextFragmentDTO
     */
    name?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateTextFragmentDTO
     */
    previousTextFragmentId?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateTextFragmentDTO
     */
    nextTextFragmentId?: number | null;
}
/**
 * 
 * @export
 * @interface UpdatedArtefactPlacementDTO
 */
export interface UpdatedArtefactPlacementDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdatedArtefactPlacementDTO
     */
    placementEditorId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatedArtefactPlacementDTO
     */
    artefactId: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatedArtefactPlacementDTO
     */
    isPlaced: boolean;
    /**
     * 
     * @type {PlacementDTO}
     * @memberof UpdatedArtefactPlacementDTO
     */
    placement?: PlacementDTO | null;
}
/**
 * 
 * @export
 * @interface UpdatedInterpretationRoiDTO
 */
export interface UpdatedInterpretationRoiDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdatedInterpretationRoiDTO
     */
    oldInterpretationRoiId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatedInterpretationRoiDTO
     */
    creatorId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatedInterpretationRoiDTO
     */
    editorId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatedInterpretationRoiDTO
     */
    interpretationRoiId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatedInterpretationRoiDTO
     */
    artefactId: number;
    /**
     * 
     * @type {number}
     * @memberof UpdatedInterpretationRoiDTO
     */
    signInterpretationId: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatedInterpretationRoiDTO
     */
    shape: string;
    /**
     * 
     * @type {TranslateDTO}
     * @memberof UpdatedInterpretationRoiDTO
     */
    translate: TranslateDTO;
    /**
     * 
     * @type {number}
     * @memberof UpdatedInterpretationRoiDTO
     */
    stanceRotation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatedInterpretationRoiDTO
     */
    exceptional: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatedInterpretationRoiDTO
     */
    valuesSet: boolean;
}
/**
 * 
 * @export
 * @interface UpdatedInterpretationRoiDTOList
 */
export interface UpdatedInterpretationRoiDTOList {
    /**
     * 
     * @type {Array<UpdatedInterpretationRoiDTO>}
     * @memberof UpdatedInterpretationRoiDTOList
     */
    rois: Array<UpdatedInterpretationRoiDTO>;
}
/**
 * 
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
    /**
     * 
     * @type {number}
     * @memberof UserDTO
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    email: string;
}
/**
 * 
 * @export
 * @interface UserUpdateRequestDTO
 */
export interface UserUpdateRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequestDTO
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequestDTO
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequestDTO
     */
    organization?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequestDTO
     */
    forename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequestDTO
     */
    surname?: string | null;
}
/**
 * 
 * @export
 * @interface WktPolygonDTO
 */
export interface WktPolygonDTO {
    /**
     * 
     * @type {string}
     * @memberof WktPolygonDTO
     */
    wktPolygon: string;
}

/**
 * ArtefactApi - axios parameter creator
 * @export
 */
export const ArtefactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes the specified artefact group.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Unique Id of the artefact group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete: async (editionId: number, artefactGroupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete.');
            }
            // verify required parameter 'artefactGroupId' is not null or undefined
            if (artefactGroupId === null || artefactGroupId === undefined) {
                throw new RequiredError('artefactGroupId','Required parameter artefactGroupId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefact-groups/{artefactGroupId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactGroupId"}}`, encodeURIComponent(String(artefactGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the details of a specific artefact group in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Id of the desired artefact group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet: async (editionId: number, artefactGroupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet.');
            }
            // verify required parameter 'artefactGroupId' is not null or undefined
            if (artefactGroupId === null || artefactGroupId === undefined) {
                throw new RequiredError('artefactGroupId','Required parameter artefactGroupId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefact-groups/{artefactGroupId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactGroupId"}}`, encodeURIComponent(String(artefactGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the details of an artefact group.  The artefact group will now only contain the artefacts listed in the JSON payload.  If the name is null, no change will be made, otherwise the name will also be updated.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Id of the artefact group to be updated
         * @param {UpdateArtefactGroupDTO} [updateArtefactGroupDTO] Parameters that the artefact group should be changed to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut: async (editionId: number, artefactGroupId: number, updateArtefactGroupDTO?: UpdateArtefactGroupDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut.');
            }
            // verify required parameter 'artefactGroupId' is not null or undefined
            if (artefactGroupId === null || artefactGroupId === undefined) {
                throw new RequiredError('artefactGroupId','Required parameter artefactGroupId was null or undefined when calling v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefact-groups/{artefactGroupId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactGroupId"}}`, encodeURIComponent(String(artefactGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateArtefactGroupDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateArtefactGroupDTO !== undefined ? updateArtefactGroupDTO : {}) : (updateArtefactGroupDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a listing of all artefact groups in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsGet: async (editionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefact-groups`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new artefact group with the submitted data.  The new artefact must have a list of artefacts that belong to the group.  It is not necessary to give the group a name.
         * @param {number} editionId Unique Id of the desired edition
         * @param {CreateArtefactGroupDTO} [createArtefactGroupDTO] Parameters of the new artefact group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsPost: async (editionId: number, createArtefactGroupDTO?: CreateArtefactGroupDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactGroupsPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefact-groups`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createArtefactGroupDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createArtefactGroupDTO !== undefined ? createArtefactGroupDTO : {}) : (createArtefactGroupDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the specified artefact
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdDelete: async (editionId: number, artefactId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdDelete.');
            }
            // verify required parameter 'artefactId' is not null or undefined
            if (artefactId === null || artefactId === undefined) {
                throw new RequiredError('artefactId','Required parameter artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdDelete.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts/{artefactId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a listing of all artefacts that are part of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdGet: async (editionId: number, artefactId: number, optional?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdGet.');
            }
            // verify required parameter 'artefactId' is not null or undefined
            if (artefactId === null || artefactId === undefined) {
                throw new RequiredError('artefactId','Required parameter artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts/{artefactId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (optional) {
                localVarQueryParameter['optional'] = optional;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the specified artefact.  There are many possible attributes that can be changed for  an artefact.  The caller should only input only those that  should be changed. Attributes with a null value will be ignored.  For instance, setting the mask to null or \"\" will result in  no changes to the current mask, and no value for the mask will  be returned (or broadcast). Likewise, the transformation, name,  or status message may be set to null and no change will be made  to those entities (though any unchanged values will be returned  along with the changed values and also broadcast to co-editors).
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {UpdateArtefactDTO} [updateArtefactDTO] An UpdateArtefactDTO with the desired alterations to the artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdPut: async (editionId: number, artefactId: number, updateArtefactDTO?: UpdateArtefactDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdPut.');
            }
            // verify required parameter 'artefactId' is not null or undefined
            if (artefactId === null || artefactId === undefined) {
                throw new RequiredError('artefactId','Required parameter artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts/{artefactId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateArtefactDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateArtefactDTO !== undefined ? updateArtefactDTO : {}) : (updateArtefactDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a listing of all rois belonging to an artefact in the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdRoisGet: async (editionId: number, artefactId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdRoisGet.');
            }
            // verify required parameter 'artefactId' is not null or undefined
            if (artefactId === null || artefactId === undefined) {
                throw new RequiredError('artefactId','Required parameter artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdRoisGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts/{artefactId}/rois`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a listing of text fragments that have text in the specified artefact.  With the optional query parameter \"suggested\", this endpoint will also return  any text fragment that the system suggests might have text in the artefact.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {Array<string>} [optional] Add \&quot;suggested\&quot; to include possible matches suggested by the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet: async (editionId: number, artefactId: number, optional?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet.');
            }
            // verify required parameter 'artefactId' is not null or undefined
            if (artefactId === null || artefactId === undefined) {
                throw new RequiredError('artefactId','Required parameter artefactId was null or undefined when calling v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts/{artefactId}/text-fragments`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (optional) {
                localVarQueryParameter['optional'] = optional;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the positional data for a batch of artefacts
         * @param {number} editionId Unique Id of the desired edition
         * @param {BatchUpdateArtefactPlacementDTO} [batchUpdateArtefactPlacementDTO] A BatchUpdateArtefactTransformDTO with a list of the desired updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsBatchTransformationPost: async (editionId: number, batchUpdateArtefactPlacementDTO?: BatchUpdateArtefactPlacementDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsBatchTransformationPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts/batch-transformation`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof batchUpdateArtefactPlacementDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(batchUpdateArtefactPlacementDTO !== undefined ? batchUpdateArtefactPlacementDTO : {}) : (batchUpdateArtefactPlacementDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a listing of all artefacts that are part of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsGet: async (editionId: number, optional?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (optional) {
                localVarQueryParameter['optional'] = optional;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new artefact with the provided data.  If no mask is provided, a placeholder mask will be created with the values:  \"POLYGON((0 0,1 1,1 0,0 0))\" (the system requires a valid WKT polygon mask for  every artefact). It is not recommended to leave the mask, name, or work status  blank or null. It will often be advantageous to leave the transformation null  when first creating a new artefact.
         * @param {number} editionId Unique Id of the desired edition
         * @param {CreateArtefactDTO} [createArtefactDTO] A CreateArtefactDTO with the data for the new artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsPost: async (editionId: number, createArtefactDTO?: CreateArtefactDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdArtefactsPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/artefacts`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createArtefactDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createArtefactDTO !== undefined ? createArtefactDTO : {}) : (createArtefactDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactApi - functional programming interface
 * @export
 */
export const ArtefactApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes the specified artefact group.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Unique Id of the artefact group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(editionId: number, artefactGroupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(editionId, artefactGroupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the details of a specific artefact group in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Id of the desired artefact group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(editionId: number, artefactGroupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactGroupDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(editionId, artefactGroupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the details of an artefact group.  The artefact group will now only contain the artefacts listed in the JSON payload.  If the name is null, no change will be made, otherwise the name will also be updated.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Id of the artefact group to be updated
         * @param {UpdateArtefactGroupDTO} [updateArtefactGroupDTO] Parameters that the artefact group should be changed to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(editionId: number, artefactGroupId: number, updateArtefactGroupDTO?: UpdateArtefactGroupDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactGroupDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(editionId, artefactGroupId, updateArtefactGroupDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a listing of all artefact groups in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactGroupsGet(editionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactGroupListDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactGroupsGet(editionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new artefact group with the submitted data.  The new artefact must have a list of artefacts that belong to the group.  It is not necessary to give the group a name.
         * @param {number} editionId Unique Id of the desired edition
         * @param {CreateArtefactGroupDTO} [createArtefactGroupDTO] Parameters of the new artefact group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactGroupsPost(editionId: number, createArtefactGroupDTO?: CreateArtefactGroupDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactGroupDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactGroupsPost(editionId, createArtefactGroupDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes the specified artefact
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsArtefactIdDelete(editionId: number, artefactId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsArtefactIdDelete(editionId, artefactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a listing of all artefacts that are part of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsArtefactIdGet(editionId: number, artefactId: number, optional?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsArtefactIdGet(editionId, artefactId, optional, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the specified artefact.  There are many possible attributes that can be changed for  an artefact.  The caller should only input only those that  should be changed. Attributes with a null value will be ignored.  For instance, setting the mask to null or \"\" will result in  no changes to the current mask, and no value for the mask will  be returned (or broadcast). Likewise, the transformation, name,  or status message may be set to null and no change will be made  to those entities (though any unchanged values will be returned  along with the changed values and also broadcast to co-editors).
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {UpdateArtefactDTO} [updateArtefactDTO] An UpdateArtefactDTO with the desired alterations to the artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsArtefactIdPut(editionId: number, artefactId: number, updateArtefactDTO?: UpdateArtefactDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsArtefactIdPut(editionId, artefactId, updateArtefactDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a listing of all rois belonging to an artefact in the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsArtefactIdRoisGet(editionId: number, artefactId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationRoiDTOList>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsArtefactIdRoisGet(editionId, artefactId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a listing of text fragments that have text in the specified artefact.  With the optional query parameter \"suggested\", this endpoint will also return  any text fragment that the system suggests might have text in the artefact.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {Array<string>} [optional] Add \&quot;suggested\&quot; to include possible matches suggested by the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(editionId: number, artefactId: number, optional?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactTextFragmentMatchListDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(editionId, artefactId, optional, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the positional data for a batch of artefacts
         * @param {number} editionId Unique Id of the desired edition
         * @param {BatchUpdateArtefactPlacementDTO} [batchUpdateArtefactPlacementDTO] A BatchUpdateArtefactTransformDTO with a list of the desired updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsBatchTransformationPost(editionId: number, batchUpdateArtefactPlacementDTO?: BatchUpdateArtefactPlacementDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchUpdatedArtefactTransformDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsBatchTransformationPost(editionId, batchUpdateArtefactPlacementDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a listing of all artefacts that are part of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsGet(editionId: number, optional?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactListDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsGet(editionId, optional, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new artefact with the provided data.  If no mask is provided, a placeholder mask will be created with the values:  \"POLYGON((0 0,1 1,1 0,0 0))\" (the system requires a valid WKT polygon mask for  every artefact). It is not recommended to leave the mask, name, or work status  blank or null. It will often be advantageous to leave the transformation null  when first creating a new artefact.
         * @param {number} editionId Unique Id of the desired edition
         * @param {CreateArtefactDTO} [createArtefactDTO] A CreateArtefactDTO with the data for the new artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdArtefactsPost(editionId: number, createArtefactDTO?: CreateArtefactDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactDTO>> {
            const localVarAxiosArgs = await ArtefactApiAxiosParamCreator(configuration).v1EditionsEditionIdArtefactsPost(editionId, createArtefactDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtefactApi - factory interface
 * @export
 */
export const ArtefactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes the specified artefact group.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Unique Id of the artefact group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(editionId: number, artefactGroupId: number, options?: any): AxiosPromise<DeleteDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(editionId, artefactGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the details of a specific artefact group in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Id of the desired artefact group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(editionId: number, artefactGroupId: number, options?: any): AxiosPromise<ArtefactGroupDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(editionId, artefactGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the details of an artefact group.  The artefact group will now only contain the artefacts listed in the JSON payload.  If the name is null, no change will be made, otherwise the name will also be updated.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactGroupId Id of the artefact group to be updated
         * @param {UpdateArtefactGroupDTO} [updateArtefactGroupDTO] Parameters that the artefact group should be changed to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(editionId: number, artefactGroupId: number, updateArtefactGroupDTO?: UpdateArtefactGroupDTO, options?: any): AxiosPromise<ArtefactGroupDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(editionId, artefactGroupId, updateArtefactGroupDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a listing of all artefact groups in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsGet(editionId: number, options?: any): AxiosPromise<ArtefactGroupListDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactGroupsGet(editionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new artefact group with the submitted data.  The new artefact must have a list of artefacts that belong to the group.  It is not necessary to give the group a name.
         * @param {number} editionId Unique Id of the desired edition
         * @param {CreateArtefactGroupDTO} [createArtefactGroupDTO] Parameters of the new artefact group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactGroupsPost(editionId: number, createArtefactGroupDTO?: CreateArtefactGroupDTO, options?: any): AxiosPromise<ArtefactGroupDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactGroupsPost(editionId, createArtefactGroupDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes the specified artefact
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdDelete(editionId: number, artefactId: number, options?: any): AxiosPromise<void> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsArtefactIdDelete(editionId, artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a listing of all artefacts that are part of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdGet(editionId: number, artefactId: number, optional?: Array<string>, options?: any): AxiosPromise<ArtefactDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsArtefactIdGet(editionId, artefactId, optional, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the specified artefact.  There are many possible attributes that can be changed for  an artefact.  The caller should only input only those that  should be changed. Attributes with a null value will be ignored.  For instance, setting the mask to null or \"\" will result in  no changes to the current mask, and no value for the mask will  be returned (or broadcast). Likewise, the transformation, name,  or status message may be set to null and no change will be made  to those entities (though any unchanged values will be returned  along with the changed values and also broadcast to co-editors).
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {UpdateArtefactDTO} [updateArtefactDTO] An UpdateArtefactDTO with the desired alterations to the artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdPut(editionId: number, artefactId: number, updateArtefactDTO?: UpdateArtefactDTO, options?: any): AxiosPromise<ArtefactDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsArtefactIdPut(editionId, artefactId, updateArtefactDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a listing of all rois belonging to an artefact in the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdRoisGet(editionId: number, artefactId: number, options?: any): AxiosPromise<InterpretationRoiDTOList> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsArtefactIdRoisGet(editionId, artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a listing of text fragments that have text in the specified artefact.  With the optional query parameter \"suggested\", this endpoint will also return  any text fragment that the system suggests might have text in the artefact.
         * @param {number} editionId Unique Id of the desired edition
         * @param {number} artefactId Unique Id of the desired artefact
         * @param {Array<string>} [optional] Add \&quot;suggested\&quot; to include possible matches suggested by the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(editionId: number, artefactId: number, optional?: Array<string>, options?: any): AxiosPromise<ArtefactTextFragmentMatchListDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(editionId, artefactId, optional, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the positional data for a batch of artefacts
         * @param {number} editionId Unique Id of the desired edition
         * @param {BatchUpdateArtefactPlacementDTO} [batchUpdateArtefactPlacementDTO] A BatchUpdateArtefactTransformDTO with a list of the desired updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsBatchTransformationPost(editionId: number, batchUpdateArtefactPlacementDTO?: BatchUpdateArtefactPlacementDTO, options?: any): AxiosPromise<BatchUpdatedArtefactTransformDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsBatchTransformationPost(editionId, batchUpdateArtefactPlacementDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a listing of all artefacts that are part of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsGet(editionId: number, optional?: Array<string>, options?: any): AxiosPromise<ArtefactListDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsGet(editionId, optional, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new artefact with the provided data.  If no mask is provided, a placeholder mask will be created with the values:  \"POLYGON((0 0,1 1,1 0,0 0))\" (the system requires a valid WKT polygon mask for  every artefact). It is not recommended to leave the mask, name, or work status  blank or null. It will often be advantageous to leave the transformation null  when first creating a new artefact.
         * @param {number} editionId Unique Id of the desired edition
         * @param {CreateArtefactDTO} [createArtefactDTO] A CreateArtefactDTO with the data for the new artefact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdArtefactsPost(editionId: number, createArtefactDTO?: CreateArtefactDTO, options?: any): AxiosPromise<ArtefactDTO> {
            return ArtefactApiFp(configuration).v1EditionsEditionIdArtefactsPost(editionId, createArtefactDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtefactApi - object-oriented interface
 * @export
 * @class ArtefactApi
 * @extends {BaseAPI}
 */
export class ArtefactApi extends BaseAPI {
    /**
     * 
     * @summary Deletes the specified artefact group.
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactGroupId Unique Id of the artefact group to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(editionId: number, artefactGroupId: number, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(editionId, artefactGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the details of a specific artefact group in the edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactGroupId Id of the desired artefact group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(editionId: number, artefactGroupId: number, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(editionId, artefactGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the details of an artefact group.  The artefact group will now only contain the artefacts listed in the JSON payload.  If the name is null, no change will be made, otherwise the name will also be updated.
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactGroupId Id of the artefact group to be updated
     * @param {UpdateArtefactGroupDTO} [updateArtefactGroupDTO] Parameters that the artefact group should be changed to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(editionId: number, artefactGroupId: number, updateArtefactGroupDTO?: UpdateArtefactGroupDTO, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(editionId, artefactGroupId, updateArtefactGroupDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a listing of all artefact groups in the edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactGroupsGet(editionId: number, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactGroupsGet(editionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new artefact group with the submitted data.  The new artefact must have a list of artefacts that belong to the group.  It is not necessary to give the group a name.
     * @param {number} editionId Unique Id of the desired edition
     * @param {CreateArtefactGroupDTO} [createArtefactGroupDTO] Parameters of the new artefact group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactGroupsPost(editionId: number, createArtefactGroupDTO?: CreateArtefactGroupDTO, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactGroupsPost(editionId, createArtefactGroupDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes the specified artefact
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactId Unique Id of the desired artefact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsArtefactIdDelete(editionId: number, artefactId: number, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsArtefactIdDelete(editionId, artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a listing of all artefacts that are part of the specified edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactId Unique Id of the desired artefact
     * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsArtefactIdGet(editionId: number, artefactId: number, optional?: Array<string>, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsArtefactIdGet(editionId, artefactId, optional, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the specified artefact.  There are many possible attributes that can be changed for  an artefact.  The caller should only input only those that  should be changed. Attributes with a null value will be ignored.  For instance, setting the mask to null or \"\" will result in  no changes to the current mask, and no value for the mask will  be returned (or broadcast). Likewise, the transformation, name,  or status message may be set to null and no change will be made  to those entities (though any unchanged values will be returned  along with the changed values and also broadcast to co-editors).
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactId Unique Id of the desired artefact
     * @param {UpdateArtefactDTO} [updateArtefactDTO] An UpdateArtefactDTO with the desired alterations to the artefact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsArtefactIdPut(editionId: number, artefactId: number, updateArtefactDTO?: UpdateArtefactDTO, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsArtefactIdPut(editionId, artefactId, updateArtefactDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a listing of all rois belonging to an artefact in the specified edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactId Unique Id of the desired artefact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsArtefactIdRoisGet(editionId: number, artefactId: number, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsArtefactIdRoisGet(editionId, artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a listing of text fragments that have text in the specified artefact.  With the optional query parameter \"suggested\", this endpoint will also return  any text fragment that the system suggests might have text in the artefact.
     * @param {number} editionId Unique Id of the desired edition
     * @param {number} artefactId Unique Id of the desired artefact
     * @param {Array<string>} [optional] Add \&quot;suggested\&quot; to include possible matches suggested by the system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(editionId: number, artefactId: number, optional?: Array<string>, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(editionId, artefactId, optional, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the positional data for a batch of artefacts
     * @param {number} editionId Unique Id of the desired edition
     * @param {BatchUpdateArtefactPlacementDTO} [batchUpdateArtefactPlacementDTO] A BatchUpdateArtefactTransformDTO with a list of the desired updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsBatchTransformationPost(editionId: number, batchUpdateArtefactPlacementDTO?: BatchUpdateArtefactPlacementDTO, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsBatchTransformationPost(editionId, batchUpdateArtefactPlacementDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a listing of all artefacts that are part of the specified edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {Array<string>} [optional] Add \&quot;masks\&quot; to include artefact polygons and \&quot;images\&quot; to include image data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsGet(editionId: number, optional?: Array<string>, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsGet(editionId, optional, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new artefact with the provided data.  If no mask is provided, a placeholder mask will be created with the values:  \"POLYGON((0 0,1 1,1 0,0 0))\" (the system requires a valid WKT polygon mask for  every artefact). It is not recommended to leave the mask, name, or work status  blank or null. It will often be advantageous to leave the transformation null  when first creating a new artefact.
     * @param {number} editionId Unique Id of the desired edition
     * @param {CreateArtefactDTO} [createArtefactDTO] A CreateArtefactDTO with the data for the new artefact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public v1EditionsEditionIdArtefactsPost(editionId: number, createArtefactDTO?: CreateArtefactDTO, options?: any) {
        return ArtefactApiFp(this.configuration).v1EditionsEditionIdArtefactsPost(editionId, createArtefactDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CatalogueApi - axios parameter creator
 * @export
 */
export const CatalogueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove an existing imaged object and text fragment match, which is not correct
         * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete: async (iaaEditionCatalogToTextFragmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'iaaEditionCatalogToTextFragmentId' is not null or undefined
            if (iaaEditionCatalogToTextFragmentId === null || iaaEditionCatalogToTextFragmentId === undefined) {
                throw new RequiredError('iaaEditionCatalogToTextFragmentId','Required parameter iaaEditionCatalogToTextFragmentId was null or undefined when calling v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete.');
            }
            const localVarPath = `/v1/catalogue/confirm-match/{iaaEditionCatalogToTextFragmentId}`
                .replace(`{${"iaaEditionCatalogToTextFragmentId"}}`, encodeURIComponent(String(iaaEditionCatalogToTextFragmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm the correctness of an existing imaged object and text fragment match
         * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost: async (iaaEditionCatalogToTextFragmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'iaaEditionCatalogToTextFragmentId' is not null or undefined
            if (iaaEditionCatalogToTextFragmentId === null || iaaEditionCatalogToTextFragmentId === undefined) {
                throw new RequiredError('iaaEditionCatalogToTextFragmentId','Required parameter iaaEditionCatalogToTextFragmentId was null or undefined when calling v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost.');
            }
            const localVarPath = `/v1/catalogue/confirm-match/{iaaEditionCatalogToTextFragmentId}`
                .replace(`{${"iaaEditionCatalogToTextFragmentId"}}`, encodeURIComponent(String(iaaEditionCatalogToTextFragmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified edition
         * @param {number} editionId Unique Id of the edition to search for imaged objects to text fragment matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet: async (editionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet.');
            }
            const localVarPath = `/v1/catalogue/editions/{editionId}/imaged-object-text-fragment-matches`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a listing of all text fragments matches that correspond to an imaged object
         * @param {string} imagedObjectId Id of imaged object to search for transcription matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet: async (imagedObjectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagedObjectId' is not null or undefined
            if (imagedObjectId === null || imagedObjectId === undefined) {
                throw new RequiredError('imagedObjectId','Required parameter imagedObjectId was null or undefined when calling v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet.');
            }
            const localVarPath = `/v1/catalogue/imaged-objects/{imagedObjectId}/text-fragments`
                .replace(`{${"imagedObjectId"}}`, encodeURIComponent(String(imagedObjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified manuscript
         * @param {number} manuscriptId Unique Id of the manuscript to search for imaged objects to text fragment matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet: async (manuscriptId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'manuscriptId' is not null or undefined
            if (manuscriptId === null || manuscriptId === undefined) {
                throw new RequiredError('manuscriptId','Required parameter manuscriptId was null or undefined when calling v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet.');
            }
            const localVarPath = `/v1/catalogue/manuscripts/{manuscriptId}/imaged-object-text-fragment-matches`
                .replace(`{${"manuscriptId"}}`, encodeURIComponent(String(manuscriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new matched pair for an imaged object and a text fragment along with the edition princeps information
         * @param {CatalogueMatchInputDTO} [catalogueMatchInputDTO] The details of the new match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CataloguePost: async (catalogueMatchInputDTO?: CatalogueMatchInputDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/catalogue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof catalogueMatchInputDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(catalogueMatchInputDTO !== undefined ? catalogueMatchInputDTO : {}) : (catalogueMatchInputDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a listing of all imaged objects that matches that correspond to a transcribed text fragment
         * @param {number} textFragmentId Unique Id of the text fragment to search for imaged object matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet: async (textFragmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'textFragmentId' is not null or undefined
            if (textFragmentId === null || textFragmentId === undefined) {
                throw new RequiredError('textFragmentId','Required parameter textFragmentId was null or undefined when calling v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet.');
            }
            const localVarPath = `/v1/catalogue/text-fragments/{textFragmentId}/imaged-objects`
                .replace(`{${"textFragmentId"}}`, encodeURIComponent(String(textFragmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogueApi - functional programming interface
 * @export
 */
export const CatalogueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove an existing imaged object and text fragment match, which is not correct
         * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete(iaaEditionCatalogToTextFragmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CatalogueApiAxiosParamCreator(configuration).v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete(iaaEditionCatalogToTextFragmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Confirm the correctness of an existing imaged object and text fragment match
         * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost(iaaEditionCatalogToTextFragmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CatalogueApiAxiosParamCreator(configuration).v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost(iaaEditionCatalogToTextFragmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified edition
         * @param {number} editionId Unique Id of the edition to search for imaged objects to text fragment matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet(editionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogueMatchListDTO>> {
            const localVarAxiosArgs = await CatalogueApiAxiosParamCreator(configuration).v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet(editionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a listing of all text fragments matches that correspond to an imaged object
         * @param {string} imagedObjectId Id of imaged object to search for transcription matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogueMatchListDTO>> {
            const localVarAxiosArgs = await CatalogueApiAxiosParamCreator(configuration).v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified manuscript
         * @param {number} manuscriptId Unique Id of the manuscript to search for imaged objects to text fragment matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet(manuscriptId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogueMatchListDTO>> {
            const localVarAxiosArgs = await CatalogueApiAxiosParamCreator(configuration).v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet(manuscriptId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new matched pair for an imaged object and a text fragment along with the edition princeps information
         * @param {CatalogueMatchInputDTO} [catalogueMatchInputDTO] The details of the new match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CataloguePost(catalogueMatchInputDTO?: CatalogueMatchInputDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CatalogueApiAxiosParamCreator(configuration).v1CataloguePost(catalogueMatchInputDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a listing of all imaged objects that matches that correspond to a transcribed text fragment
         * @param {number} textFragmentId Unique Id of the text fragment to search for imaged object matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet(textFragmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogueMatchListDTO>> {
            const localVarAxiosArgs = await CatalogueApiAxiosParamCreator(configuration).v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet(textFragmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CatalogueApi - factory interface
 * @export
 */
export const CatalogueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Remove an existing imaged object and text fragment match, which is not correct
         * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete(iaaEditionCatalogToTextFragmentId: number, options?: any): AxiosPromise<void> {
            return CatalogueApiFp(configuration).v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete(iaaEditionCatalogToTextFragmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm the correctness of an existing imaged object and text fragment match
         * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost(iaaEditionCatalogToTextFragmentId: number, options?: any): AxiosPromise<void> {
            return CatalogueApiFp(configuration).v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost(iaaEditionCatalogToTextFragmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified edition
         * @param {number} editionId Unique Id of the edition to search for imaged objects to text fragment matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet(editionId: number, options?: any): AxiosPromise<CatalogueMatchListDTO> {
            return CatalogueApiFp(configuration).v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet(editionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a listing of all text fragments matches that correspond to an imaged object
         * @param {string} imagedObjectId Id of imaged object to search for transcription matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId: string, options?: any): AxiosPromise<CatalogueMatchListDTO> {
            return CatalogueApiFp(configuration).v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified manuscript
         * @param {number} manuscriptId Unique Id of the manuscript to search for imaged objects to text fragment matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet(manuscriptId: number, options?: any): AxiosPromise<CatalogueMatchListDTO> {
            return CatalogueApiFp(configuration).v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet(manuscriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new matched pair for an imaged object and a text fragment along with the edition princeps information
         * @param {CatalogueMatchInputDTO} [catalogueMatchInputDTO] The details of the new match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CataloguePost(catalogueMatchInputDTO?: CatalogueMatchInputDTO, options?: any): AxiosPromise<void> {
            return CatalogueApiFp(configuration).v1CataloguePost(catalogueMatchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a listing of all imaged objects that matches that correspond to a transcribed text fragment
         * @param {number} textFragmentId Unique Id of the text fragment to search for imaged object matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet(textFragmentId: number, options?: any): AxiosPromise<CatalogueMatchListDTO> {
            return CatalogueApiFp(configuration).v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet(textFragmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogueApi - object-oriented interface
 * @export
 * @class CatalogueApi
 * @extends {BaseAPI}
 */
export class CatalogueApi extends BaseAPI {
    /**
     * 
     * @summary Remove an existing imaged object and text fragment match, which is not correct
     * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogueApi
     */
    public v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete(iaaEditionCatalogToTextFragmentId: number, options?: any) {
        return CatalogueApiFp(this.configuration).v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete(iaaEditionCatalogToTextFragmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm the correctness of an existing imaged object and text fragment match
     * @param {number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogueApi
     */
    public v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost(iaaEditionCatalogToTextFragmentId: number, options?: any) {
        return CatalogueApiFp(this.configuration).v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost(iaaEditionCatalogToTextFragmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified edition
     * @param {number} editionId Unique Id of the edition to search for imaged objects to text fragment matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogueApi
     */
    public v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet(editionId: number, options?: any) {
        return CatalogueApiFp(this.configuration).v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet(editionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a listing of all text fragments matches that correspond to an imaged object
     * @param {string} imagedObjectId Id of imaged object to search for transcription matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogueApi
     */
    public v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId: string, options?: any) {
        return CatalogueApiFp(this.configuration).v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a listing of all corresponding imaged objects and transcribed text fragment in a specified manuscript
     * @param {number} manuscriptId Unique Id of the manuscript to search for imaged objects to text fragment matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogueApi
     */
    public v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet(manuscriptId: number, options?: any) {
        return CatalogueApiFp(this.configuration).v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet(manuscriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new matched pair for an imaged object and a text fragment along with the edition princeps information
     * @param {CatalogueMatchInputDTO} [catalogueMatchInputDTO] The details of the new match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogueApi
     */
    public v1CataloguePost(catalogueMatchInputDTO?: CatalogueMatchInputDTO, options?: any) {
        return CatalogueApiFp(this.configuration).v1CataloguePost(catalogueMatchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a listing of all imaged objects that matches that correspond to a transcribed text fragment
     * @param {number} textFragmentId Unique Id of the text fragment to search for imaged object matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogueApi
     */
    public v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet(textFragmentId: number, options?: any) {
        return CatalogueApiFp(this.configuration).v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet(textFragmentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EditionApi - axios parameter creator
 * @export
 */
export const EditionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of requests issued by the current user for other users  to become editors of a shared edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsAdminShareRequestsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/editions/admin-share-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm addition of an editor to the specified edition
         * @param {string} token JWT for verifying the request confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsConfirmEditorshipTokenPost: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling v1EditionsConfirmEditorshipTokenPost.');
            }
            const localVarPath = `/v1/editions/confirm-editorship/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an editor to the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {InviteEditorDTO} [inviteEditorDTO] JSON object with the attributes of the new editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdAddEditorRequestPost: async (editionId: number, inviteEditorDTO?: InviteEditorDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdAddEditorRequestPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/add-editor-request`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inviteEditorDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inviteEditorDTO !== undefined ? inviteEditorDTO : {}) : (inviteEditorDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides details about the specified edition and all accessible alternate editions
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Optional parameters: \&#39;deleteForAllEditors\&#39;
         * @param {string} [token] token required when using optional \&#39;deleteForAllEditors\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdDelete: async (editionId: number, optional?: Array<string>, token?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdDelete.');
            }
            const localVarPath = `/v1/editions/{editionId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (optional) {
                localVarQueryParameter['optional'] = optional;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Changes the rights for an editor of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {string} editorEmailId Email address of the editor whose permissions are being changed
         * @param {UpdateEditorRightsDTO} [updateEditorRightsDTO] JSON object with the attributes of the new editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdEditorsEditorEmailIdPut: async (editionId: number, editorEmailId: string, updateEditorRightsDTO?: UpdateEditorRightsDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdEditorsEditorEmailIdPut.');
            }
            // verify required parameter 'editorEmailId' is not null or undefined
            if (editorEmailId === null || editorEmailId === undefined) {
                throw new RequiredError('editorEmailId','Required parameter editorEmailId was null or undefined when calling v1EditionsEditionIdEditorsEditorEmailIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/editors/{editorEmailId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"editorEmailId"}}`, encodeURIComponent(String(editorEmailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateEditorRightsDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateEditorRightsDTO !== undefined ? updateEditorRightsDTO : {}) : (updateEditorRightsDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides details about the specified edition and all accessible alternate editions
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdGet: async (editionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a copy of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {EditionCopyDTO} [editionCopyDTO] JSON object with the attributes to be changed in the copied edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdPost: async (editionId: number, editionCopyDTO?: EditionCopyDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdPost.');
            }
            const localVarPath = `/v1/editions/{editionId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof editionCopyDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(editionCopyDTO !== undefined ? editionCopyDTO : {}) : (editionCopyDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates data for the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {EditionUpdateRequestDTO} [editionUpdateRequestDTO] JSON object with the attributes to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdPut: async (editionId: number, editionUpdateRequestDTO?: EditionUpdateRequestDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof editionUpdateRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(editionUpdateRequestDTO !== undefined ? editionUpdateRequestDTO : {}) : (editionUpdateRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides spatial data for all letters in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdScriptCollectionGet: async (editionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdScriptCollectionGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/script-collection`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides spatial data for all letters in the edition organized and oriented  by lines.
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdScriptLinesGet: async (editionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdScriptLinesGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/script-lines`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of invitations issued to the current user to become an editor of a shared edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditorInvitationsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/editions/editor-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a listing of all editions accessible to the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/editions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EditionApi - functional programming interface
 * @export
 */
export const EditionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of requests issued by the current user for other users  to become editors of a shared edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsAdminShareRequestsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminEditorRequestListDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsAdminShareRequestsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Confirm addition of an editor to the specified edition
         * @param {string} token JWT for verifying the request confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsConfirmEditorshipTokenPost(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedEditorRightsDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsConfirmEditorshipTokenPost(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds an editor to the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {InviteEditorDTO} [inviteEditorDTO] JSON object with the attributes of the new editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdAddEditorRequestPost(editionId: number, inviteEditorDTO?: InviteEditorDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdAddEditorRequestPost(editionId, inviteEditorDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides details about the specified edition and all accessible alternate editions
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Optional parameters: \&#39;deleteForAllEditors\&#39;
         * @param {string} [token] token required when using optional \&#39;deleteForAllEditors\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdDelete(editionId: number, optional?: Array<string>, token?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTokenDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdDelete(editionId, optional, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Changes the rights for an editor of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {string} editorEmailId Email address of the editor whose permissions are being changed
         * @param {UpdateEditorRightsDTO} [updateEditorRightsDTO] JSON object with the attributes of the new editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdEditorsEditorEmailIdPut(editionId: number, editorEmailId: string, updateEditorRightsDTO?: UpdateEditorRightsDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedEditorRightsDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdEditorsEditorEmailIdPut(editionId, editorEmailId, updateEditorRightsDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides details about the specified edition and all accessible alternate editions
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdGet(editionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditionGroupDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdGet(editionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a copy of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {EditionCopyDTO} [editionCopyDTO] JSON object with the attributes to be changed in the copied edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdPost(editionId: number, editionCopyDTO?: EditionCopyDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditionDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdPost(editionId, editionCopyDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates data for the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {EditionUpdateRequestDTO} [editionUpdateRequestDTO] JSON object with the attributes to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdPut(editionId: number, editionUpdateRequestDTO?: EditionUpdateRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditionDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdPut(editionId, editionUpdateRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides spatial data for all letters in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdScriptCollectionGet(editionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditionScriptCollectionDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdScriptCollectionGet(editionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides spatial data for all letters in the edition organized and oriented  by lines.
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdScriptLinesGet(editionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditionScriptLinesDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditionIdScriptLinesGet(editionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of invitations issued to the current user to become an editor of a shared edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditorInvitationsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditorInvitationListDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsEditorInvitationsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a listing of all editions accessible to the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EditionListDTO>> {
            const localVarAxiosArgs = await EditionApiAxiosParamCreator(configuration).v1EditionsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EditionApi - factory interface
 * @export
 */
export const EditionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get a list of requests issued by the current user for other users  to become editors of a shared edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsAdminShareRequestsGet(options?: any): AxiosPromise<AdminEditorRequestListDTO> {
            return EditionApiFp(configuration).v1EditionsAdminShareRequestsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm addition of an editor to the specified edition
         * @param {string} token JWT for verifying the request confirmation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsConfirmEditorshipTokenPost(token: string, options?: any): AxiosPromise<DetailedEditorRightsDTO> {
            return EditionApiFp(configuration).v1EditionsConfirmEditorshipTokenPost(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds an editor to the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {InviteEditorDTO} [inviteEditorDTO] JSON object with the attributes of the new editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdAddEditorRequestPost(editionId: number, inviteEditorDTO?: InviteEditorDTO, options?: any): AxiosPromise<void> {
            return EditionApiFp(configuration).v1EditionsEditionIdAddEditorRequestPost(editionId, inviteEditorDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides details about the specified edition and all accessible alternate editions
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Optional parameters: \&#39;deleteForAllEditors\&#39;
         * @param {string} [token] token required when using optional \&#39;deleteForAllEditors\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdDelete(editionId: number, optional?: Array<string>, token?: string, options?: any): AxiosPromise<DeleteTokenDTO> {
            return EditionApiFp(configuration).v1EditionsEditionIdDelete(editionId, optional, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Changes the rights for an editor of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {string} editorEmailId Email address of the editor whose permissions are being changed
         * @param {UpdateEditorRightsDTO} [updateEditorRightsDTO] JSON object with the attributes of the new editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdEditorsEditorEmailIdPut(editionId: number, editorEmailId: string, updateEditorRightsDTO?: UpdateEditorRightsDTO, options?: any): AxiosPromise<DetailedEditorRightsDTO> {
            return EditionApiFp(configuration).v1EditionsEditionIdEditorsEditorEmailIdPut(editionId, editorEmailId, updateEditorRightsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides details about the specified edition and all accessible alternate editions
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdGet(editionId: number, options?: any): AxiosPromise<EditionGroupDTO> {
            return EditionApiFp(configuration).v1EditionsEditionIdGet(editionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a copy of the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {EditionCopyDTO} [editionCopyDTO] JSON object with the attributes to be changed in the copied edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdPost(editionId: number, editionCopyDTO?: EditionCopyDTO, options?: any): AxiosPromise<EditionDTO> {
            return EditionApiFp(configuration).v1EditionsEditionIdPost(editionId, editionCopyDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates data for the specified edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {EditionUpdateRequestDTO} [editionUpdateRequestDTO] JSON object with the attributes to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdPut(editionId: number, editionUpdateRequestDTO?: EditionUpdateRequestDTO, options?: any): AxiosPromise<EditionDTO> {
            return EditionApiFp(configuration).v1EditionsEditionIdPut(editionId, editionUpdateRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides spatial data for all letters in the edition
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdScriptCollectionGet(editionId: number, options?: any): AxiosPromise<EditionScriptCollectionDTO> {
            return EditionApiFp(configuration).v1EditionsEditionIdScriptCollectionGet(editionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides spatial data for all letters in the edition organized and oriented  by lines.
         * @param {number} editionId Unique Id of the desired edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdScriptLinesGet(editionId: number, options?: any): AxiosPromise<EditionScriptLinesDTO> {
            return EditionApiFp(configuration).v1EditionsEditionIdScriptLinesGet(editionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of invitations issued to the current user to become an editor of a shared edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditorInvitationsGet(options?: any): AxiosPromise<EditorInvitationListDTO> {
            return EditionApiFp(configuration).v1EditionsEditorInvitationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a listing of all editions accessible to the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsGet(options?: any): AxiosPromise<EditionListDTO> {
            return EditionApiFp(configuration).v1EditionsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EditionApi - object-oriented interface
 * @export
 * @class EditionApi
 * @extends {BaseAPI}
 */
export class EditionApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of requests issued by the current user for other users  to become editors of a shared edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsAdminShareRequestsGet(options?: any) {
        return EditionApiFp(this.configuration).v1EditionsAdminShareRequestsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm addition of an editor to the specified edition
     * @param {string} token JWT for verifying the request confirmation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsConfirmEditorshipTokenPost(token: string, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsConfirmEditorshipTokenPost(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds an editor to the specified edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {InviteEditorDTO} [inviteEditorDTO] JSON object with the attributes of the new editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdAddEditorRequestPost(editionId: number, inviteEditorDTO?: InviteEditorDTO, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdAddEditorRequestPost(editionId, inviteEditorDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides details about the specified edition and all accessible alternate editions
     * @param {number} editionId Unique Id of the desired edition
     * @param {Array<string>} [optional] Optional parameters: \&#39;deleteForAllEditors\&#39;
     * @param {string} [token] token required when using optional \&#39;deleteForAllEditors\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdDelete(editionId: number, optional?: Array<string>, token?: string, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdDelete(editionId, optional, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Changes the rights for an editor of the specified edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {string} editorEmailId Email address of the editor whose permissions are being changed
     * @param {UpdateEditorRightsDTO} [updateEditorRightsDTO] JSON object with the attributes of the new editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdEditorsEditorEmailIdPut(editionId: number, editorEmailId: string, updateEditorRightsDTO?: UpdateEditorRightsDTO, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdEditorsEditorEmailIdPut(editionId, editorEmailId, updateEditorRightsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides details about the specified edition and all accessible alternate editions
     * @param {number} editionId Unique Id of the desired edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdGet(editionId: number, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdGet(editionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a copy of the specified edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {EditionCopyDTO} [editionCopyDTO] JSON object with the attributes to be changed in the copied edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdPost(editionId: number, editionCopyDTO?: EditionCopyDTO, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdPost(editionId, editionCopyDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates data for the specified edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {EditionUpdateRequestDTO} [editionUpdateRequestDTO] JSON object with the attributes to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdPut(editionId: number, editionUpdateRequestDTO?: EditionUpdateRequestDTO, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdPut(editionId, editionUpdateRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides spatial data for all letters in the edition
     * @param {number} editionId Unique Id of the desired edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdScriptCollectionGet(editionId: number, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdScriptCollectionGet(editionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides spatial data for all letters in the edition organized and oriented  by lines.
     * @param {number} editionId Unique Id of the desired edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditionIdScriptLinesGet(editionId: number, options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditionIdScriptLinesGet(editionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of invitations issued to the current user to become an editor of a shared edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsEditorInvitationsGet(options?: any) {
        return EditionApiFp(this.configuration).v1EditionsEditorInvitationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a listing of all editions accessible to the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EditionApi
     */
    public v1EditionsGet(options?: any) {
        return EditionApiFp(this.configuration).v1EditionsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagedObjectApi - axios parameter creator
 * @export
 */
export const ImagedObjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provides a listing of imaged objects related to the specified edition, can include images and also their masks with  optional.
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdImagedObjectsGet: async (editionId: number, optional?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdImagedObjectsGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/imaged-objects`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (optional) {
                localVarQueryParameter['optional'] = optional;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides information for the specified imaged object related to the specified edition, can include images and also  their masks with optional.
         * @param {number} editionId Unique Id of the desired edition
         * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
         * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdImagedObjectsImagedObjectIdGet: async (editionId: number, imagedObjectId: string, optional?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdImagedObjectsImagedObjectIdGet.');
            }
            // verify required parameter 'imagedObjectId' is not null or undefined
            if (imagedObjectId === null || imagedObjectId === undefined) {
                throw new RequiredError('imagedObjectId','Required parameter imagedObjectId was null or undefined when calling v1EditionsEditionIdImagedObjectsImagedObjectIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/imaged-objects/{imagedObjectId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"imagedObjectId"}}`, encodeURIComponent(String(imagedObjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (optional) {
                localVarQueryParameter['optional'] = optional;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides information for the specified imaged object.
         * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsImagedObjectIdGet: async (imagedObjectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagedObjectId' is not null or undefined
            if (imagedObjectId === null || imagedObjectId === undefined) {
                throw new RequiredError('imagedObjectId','Required parameter imagedObjectId was null or undefined when calling v1ImagedObjectsImagedObjectIdGet.');
            }
            const localVarPath = `/v1/imaged-objects/{imagedObjectId}`
                .replace(`{${"imagedObjectId"}}`, encodeURIComponent(String(imagedObjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a list of all text fragments that should correspond to the imaged object.
         * @param {string} imagedObjectId Id of the imaged object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsImagedObjectIdTextFragmentsGet: async (imagedObjectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagedObjectId' is not null or undefined
            if (imagedObjectId === null || imagedObjectId === undefined) {
                throw new RequiredError('imagedObjectId','Required parameter imagedObjectId was null or undefined when calling v1ImagedObjectsImagedObjectIdTextFragmentsGet.');
            }
            const localVarPath = `/v1/imaged-objects/{imagedObjectId}/text-fragments`
                .replace(`{${"imagedObjectId"}}`, encodeURIComponent(String(imagedObjectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a list of all institutional image providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsInstitutionsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/imaged-objects/institutions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a list of all institutional image providers.
         * @param {string} institutionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsInstitutionsInstitutionNameGet: async (institutionName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'institutionName' is not null or undefined
            if (institutionName === null || institutionName === undefined) {
                throw new RequiredError('institutionName','Required parameter institutionName was null or undefined when calling v1ImagedObjectsInstitutionsInstitutionNameGet.');
            }
            const localVarPath = `/v1/imaged-objects/institutions/{institutionName}`
                .replace(`{${"institutionName"}}`, encodeURIComponent(String(institutionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagedObjectApi - functional programming interface
 * @export
 */
export const ImagedObjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provides a listing of imaged objects related to the specified edition, can include images and also their masks with  optional.
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdImagedObjectsGet(editionId: number, optional?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagedObjectListDTO>> {
            const localVarAxiosArgs = await ImagedObjectApiAxiosParamCreator(configuration).v1EditionsEditionIdImagedObjectsGet(editionId, optional, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides information for the specified imaged object related to the specified edition, can include images and also  their masks with optional.
         * @param {number} editionId Unique Id of the desired edition
         * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
         * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdImagedObjectsImagedObjectIdGet(editionId: number, imagedObjectId: string, optional?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagedObjectDTO>> {
            const localVarAxiosArgs = await ImagedObjectApiAxiosParamCreator(configuration).v1EditionsEditionIdImagedObjectsImagedObjectIdGet(editionId, imagedObjectId, optional, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides information for the specified imaged object.
         * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ImagedObjectsImagedObjectIdGet(imagedObjectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleImageListDTO>> {
            const localVarAxiosArgs = await ImagedObjectApiAxiosParamCreator(configuration).v1ImagedObjectsImagedObjectIdGet(imagedObjectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a list of all text fragments that should correspond to the imaged object.
         * @param {string} imagedObjectId Id of the imaged object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagedObjectTextFragmentMatchListDTO>> {
            const localVarAxiosArgs = await ImagedObjectApiAxiosParamCreator(configuration).v1ImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a list of all institutional image providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ImagedObjectsInstitutionsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInstitutionListDTO>> {
            const localVarAxiosArgs = await ImagedObjectApiAxiosParamCreator(configuration).v1ImagedObjectsInstitutionsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a list of all institutional image providers.
         * @param {string} institutionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ImagedObjectsInstitutionsInstitutionNameGet(institutionName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstitutionalImageListDTO>> {
            const localVarAxiosArgs = await ImagedObjectApiAxiosParamCreator(configuration).v1ImagedObjectsInstitutionsInstitutionNameGet(institutionName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImagedObjectApi - factory interface
 * @export
 */
export const ImagedObjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Provides a listing of imaged objects related to the specified edition, can include images and also their masks with  optional.
         * @param {number} editionId Unique Id of the desired edition
         * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdImagedObjectsGet(editionId: number, optional?: Array<string>, options?: any): AxiosPromise<ImagedObjectListDTO> {
            return ImagedObjectApiFp(configuration).v1EditionsEditionIdImagedObjectsGet(editionId, optional, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides information for the specified imaged object related to the specified edition, can include images and also  their masks with optional.
         * @param {number} editionId Unique Id of the desired edition
         * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
         * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdImagedObjectsImagedObjectIdGet(editionId: number, imagedObjectId: string, optional?: Array<string>, options?: any): AxiosPromise<ImagedObjectDTO> {
            return ImagedObjectApiFp(configuration).v1EditionsEditionIdImagedObjectsImagedObjectIdGet(editionId, imagedObjectId, optional, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides information for the specified imaged object.
         * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsImagedObjectIdGet(imagedObjectId: string, options?: any): AxiosPromise<SimpleImageListDTO> {
            return ImagedObjectApiFp(configuration).v1ImagedObjectsImagedObjectIdGet(imagedObjectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a list of all text fragments that should correspond to the imaged object.
         * @param {string} imagedObjectId Id of the imaged object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId: string, options?: any): AxiosPromise<ImagedObjectTextFragmentMatchListDTO> {
            return ImagedObjectApiFp(configuration).v1ImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a list of all institutional image providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsInstitutionsGet(options?: any): AxiosPromise<ImageInstitutionListDTO> {
            return ImagedObjectApiFp(configuration).v1ImagedObjectsInstitutionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a list of all institutional image providers.
         * @param {string} institutionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImagedObjectsInstitutionsInstitutionNameGet(institutionName: string, options?: any): AxiosPromise<InstitutionalImageListDTO> {
            return ImagedObjectApiFp(configuration).v1ImagedObjectsInstitutionsInstitutionNameGet(institutionName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagedObjectApi - object-oriented interface
 * @export
 * @class ImagedObjectApi
 * @extends {BaseAPI}
 */
export class ImagedObjectApi extends BaseAPI {
    /**
     * 
     * @summary Provides a listing of imaged objects related to the specified edition, can include images and also their masks with  optional.
     * @param {number} editionId Unique Id of the desired edition
     * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagedObjectApi
     */
    public v1EditionsEditionIdImagedObjectsGet(editionId: number, optional?: Array<string>, options?: any) {
        return ImagedObjectApiFp(this.configuration).v1EditionsEditionIdImagedObjectsGet(editionId, optional, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides information for the specified imaged object related to the specified edition, can include images and also  their masks with optional.
     * @param {number} editionId Unique Id of the desired edition
     * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
     * @param {Array<string>} [optional] Set \&#39;artefacts\&#39; to receive related artefact data and \&#39;masks\&#39; to include the artefact masks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagedObjectApi
     */
    public v1EditionsEditionIdImagedObjectsImagedObjectIdGet(editionId: number, imagedObjectId: string, optional?: Array<string>, options?: any) {
        return ImagedObjectApiFp(this.configuration).v1EditionsEditionIdImagedObjectsImagedObjectIdGet(editionId, imagedObjectId, optional, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides information for the specified imaged object.
     * @param {string} imagedObjectId Unique Id of the desired object from the imaging Institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagedObjectApi
     */
    public v1ImagedObjectsImagedObjectIdGet(imagedObjectId: string, options?: any) {
        return ImagedObjectApiFp(this.configuration).v1ImagedObjectsImagedObjectIdGet(imagedObjectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a list of all text fragments that should correspond to the imaged object.
     * @param {string} imagedObjectId Id of the imaged object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagedObjectApi
     */
    public v1ImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId: string, options?: any) {
        return ImagedObjectApiFp(this.configuration).v1ImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a list of all institutional image providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagedObjectApi
     */
    public v1ImagedObjectsInstitutionsGet(options?: any) {
        return ImagedObjectApiFp(this.configuration).v1ImagedObjectsInstitutionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a list of all institutional image providers.
     * @param {string} institutionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagedObjectApi
     */
    public v1ImagedObjectsInstitutionsInstitutionNameGet(institutionName: string, options?: any) {
        return ImagedObjectApiFp(this.configuration).v1ImagedObjectsInstitutionsInstitutionNameGet(institutionName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoiApi - axios parameter creator
 * @export
 */
export const RoiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Processes a series of create/update/delete ROI requests in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {BatchEditRoiDTO} [batchEditRoiDTO] A JSON object with all the roi edits to be performed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisBatchEditPost: async (editionId: number, batchEditRoiDTO?: BatchEditRoiDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdRoisBatchEditPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/rois/batch-edit`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof batchEditRoiDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(batchEditRoiDTO !== undefined ? batchEditRoiDTO : {}) : (batchEditRoiDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new sign ROI\'s in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {SetInterpretationRoiDTOList} [setInterpretationRoiDTOList] A JSON object with an array of the new ROI\&#39;s to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisBatchPost: async (editionId: number, setInterpretationRoiDTOList?: SetInterpretationRoiDTOList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdRoisBatchPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/rois/batch`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof setInterpretationRoiDTOList !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(setInterpretationRoiDTOList !== undefined ? setInterpretationRoiDTOList : {}) : (setInterpretationRoiDTOList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing sign ROI\'s in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {UpdateInterpretationRoiDTOList} [updateInterpretationRoiDTOList] A JSON object with an array of the updated ROI details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisBatchPut: async (editionId: number, updateInterpretationRoiDTOList?: UpdateInterpretationRoiDTOList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdRoisBatchPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/rois/batch`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateInterpretationRoiDTOList !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateInterpretationRoiDTOList !== undefined ? updateInterpretationRoiDTOList : {}) : (updateInterpretationRoiDTOList || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new sign ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the new ROI to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisPost: async (editionId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdRoisPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/rois`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof setInterpretationRoiDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(setInterpretationRoiDTO !== undefined ? setInterpretationRoiDTO : {}) : (setInterpretationRoiDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a sign ROI from the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId Id of the ROI to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisRoiIdDelete: async (editionId: number, roiId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdRoisRoiIdDelete.');
            }
            // verify required parameter 'roiId' is not null or undefined
            if (roiId === null || roiId === undefined) {
                throw new RequiredError('roiId','Required parameter roiId was null or undefined when calling v1EditionsEditionIdRoisRoiIdDelete.');
            }
            const localVarPath = `/v1/editions/{editionId}/rois/{roiId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"roiId"}}`, encodeURIComponent(String(roiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId A JSON object with the new ROI to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisRoiIdGet: async (editionId: number, roiId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdRoisRoiIdGet.');
            }
            // verify required parameter 'roiId' is not null or undefined
            if (roiId === null || roiId === undefined) {
                throw new RequiredError('roiId','Required parameter roiId was null or undefined when calling v1EditionsEditionIdRoisRoiIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/rois/{roiId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"roiId"}}`, encodeURIComponent(String(roiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing sign ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId Id of the ROI to be updated
         * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the updated ROI details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisRoiIdPut: async (editionId: number, roiId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdRoisRoiIdPut.');
            }
            // verify required parameter 'roiId' is not null or undefined
            if (roiId === null || roiId === undefined) {
                throw new RequiredError('roiId','Required parameter roiId was null or undefined when calling v1EditionsEditionIdRoisRoiIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/rois/{roiId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"roiId"}}`, encodeURIComponent(String(roiId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof setInterpretationRoiDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(setInterpretationRoiDTO !== undefined ? setInterpretationRoiDTO : {}) : (setInterpretationRoiDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoiApi - functional programming interface
 * @export
 */
export const RoiApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Processes a series of create/update/delete ROI requests in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {BatchEditRoiDTO} [batchEditRoiDTO] A JSON object with all the roi edits to be performed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdRoisBatchEditPost(editionId: number, batchEditRoiDTO?: BatchEditRoiDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchEditRoiResponseDTO>> {
            const localVarAxiosArgs = await RoiApiAxiosParamCreator(configuration).v1EditionsEditionIdRoisBatchEditPost(editionId, batchEditRoiDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates new sign ROI\'s in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {SetInterpretationRoiDTOList} [setInterpretationRoiDTOList] A JSON object with an array of the new ROI\&#39;s to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdRoisBatchPost(editionId: number, setInterpretationRoiDTOList?: SetInterpretationRoiDTOList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationRoiDTOList>> {
            const localVarAxiosArgs = await RoiApiAxiosParamCreator(configuration).v1EditionsEditionIdRoisBatchPost(editionId, setInterpretationRoiDTOList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update existing sign ROI\'s in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {UpdateInterpretationRoiDTOList} [updateInterpretationRoiDTOList] A JSON object with an array of the updated ROI details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdRoisBatchPut(editionId: number, updateInterpretationRoiDTOList?: UpdateInterpretationRoiDTOList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatedInterpretationRoiDTOList>> {
            const localVarAxiosArgs = await RoiApiAxiosParamCreator(configuration).v1EditionsEditionIdRoisBatchPut(editionId, updateInterpretationRoiDTOList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates new sign ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the new ROI to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdRoisPost(editionId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationRoiDTO>> {
            const localVarAxiosArgs = await RoiApiAxiosParamCreator(configuration).v1EditionsEditionIdRoisPost(editionId, setInterpretationRoiDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a sign ROI from the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId Id of the ROI to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdRoisRoiIdDelete(editionId: number, roiId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RoiApiAxiosParamCreator(configuration).v1EditionsEditionIdRoisRoiIdDelete(editionId, roiId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the details for a ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId A JSON object with the new ROI to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdRoisRoiIdGet(editionId: number, roiId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterpretationRoiDTO>> {
            const localVarAxiosArgs = await RoiApiAxiosParamCreator(configuration).v1EditionsEditionIdRoisRoiIdGet(editionId, roiId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an existing sign ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId Id of the ROI to be updated
         * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the updated ROI details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdRoisRoiIdPut(editionId: number, roiId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatedInterpretationRoiDTO>> {
            const localVarAxiosArgs = await RoiApiAxiosParamCreator(configuration).v1EditionsEditionIdRoisRoiIdPut(editionId, roiId, setInterpretationRoiDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoiApi - factory interface
 * @export
 */
export const RoiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Processes a series of create/update/delete ROI requests in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {BatchEditRoiDTO} [batchEditRoiDTO] A JSON object with all the roi edits to be performed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisBatchEditPost(editionId: number, batchEditRoiDTO?: BatchEditRoiDTO, options?: any): AxiosPromise<BatchEditRoiResponseDTO> {
            return RoiApiFp(configuration).v1EditionsEditionIdRoisBatchEditPost(editionId, batchEditRoiDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates new sign ROI\'s in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {SetInterpretationRoiDTOList} [setInterpretationRoiDTOList] A JSON object with an array of the new ROI\&#39;s to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisBatchPost(editionId: number, setInterpretationRoiDTOList?: SetInterpretationRoiDTOList, options?: any): AxiosPromise<InterpretationRoiDTOList> {
            return RoiApiFp(configuration).v1EditionsEditionIdRoisBatchPost(editionId, setInterpretationRoiDTOList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update existing sign ROI\'s in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {UpdateInterpretationRoiDTOList} [updateInterpretationRoiDTOList] A JSON object with an array of the updated ROI details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisBatchPut(editionId: number, updateInterpretationRoiDTOList?: UpdateInterpretationRoiDTOList, options?: any): AxiosPromise<UpdatedInterpretationRoiDTOList> {
            return RoiApiFp(configuration).v1EditionsEditionIdRoisBatchPut(editionId, updateInterpretationRoiDTOList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates new sign ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the new ROI to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisPost(editionId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options?: any): AxiosPromise<InterpretationRoiDTO> {
            return RoiApiFp(configuration).v1EditionsEditionIdRoisPost(editionId, setInterpretationRoiDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a sign ROI from the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId Id of the ROI to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisRoiIdDelete(editionId: number, roiId: number, options?: any): AxiosPromise<void> {
            return RoiApiFp(configuration).v1EditionsEditionIdRoisRoiIdDelete(editionId, roiId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId A JSON object with the new ROI to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisRoiIdGet(editionId: number, roiId: number, options?: any): AxiosPromise<InterpretationRoiDTO> {
            return RoiApiFp(configuration).v1EditionsEditionIdRoisRoiIdGet(editionId, roiId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing sign ROI in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {number} roiId Id of the ROI to be updated
         * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the updated ROI details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdRoisRoiIdPut(editionId: number, roiId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options?: any): AxiosPromise<UpdatedInterpretationRoiDTO> {
            return RoiApiFp(configuration).v1EditionsEditionIdRoisRoiIdPut(editionId, roiId, setInterpretationRoiDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoiApi - object-oriented interface
 * @export
 * @class RoiApi
 * @extends {BaseAPI}
 */
export class RoiApi extends BaseAPI {
    /**
     * 
     * @summary Processes a series of create/update/delete ROI requests in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {BatchEditRoiDTO} [batchEditRoiDTO] A JSON object with all the roi edits to be performed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoiApi
     */
    public v1EditionsEditionIdRoisBatchEditPost(editionId: number, batchEditRoiDTO?: BatchEditRoiDTO, options?: any) {
        return RoiApiFp(this.configuration).v1EditionsEditionIdRoisBatchEditPost(editionId, batchEditRoiDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates new sign ROI\'s in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {SetInterpretationRoiDTOList} [setInterpretationRoiDTOList] A JSON object with an array of the new ROI\&#39;s to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoiApi
     */
    public v1EditionsEditionIdRoisBatchPost(editionId: number, setInterpretationRoiDTOList?: SetInterpretationRoiDTOList, options?: any) {
        return RoiApiFp(this.configuration).v1EditionsEditionIdRoisBatchPost(editionId, setInterpretationRoiDTOList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update existing sign ROI\'s in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {UpdateInterpretationRoiDTOList} [updateInterpretationRoiDTOList] A JSON object with an array of the updated ROI details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoiApi
     */
    public v1EditionsEditionIdRoisBatchPut(editionId: number, updateInterpretationRoiDTOList?: UpdateInterpretationRoiDTOList, options?: any) {
        return RoiApiFp(this.configuration).v1EditionsEditionIdRoisBatchPut(editionId, updateInterpretationRoiDTOList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates new sign ROI in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the new ROI to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoiApi
     */
    public v1EditionsEditionIdRoisPost(editionId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options?: any) {
        return RoiApiFp(this.configuration).v1EditionsEditionIdRoisPost(editionId, setInterpretationRoiDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a sign ROI from the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {number} roiId Id of the ROI to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoiApi
     */
    public v1EditionsEditionIdRoisRoiIdDelete(editionId: number, roiId: number, options?: any) {
        return RoiApiFp(this.configuration).v1EditionsEditionIdRoisRoiIdDelete(editionId, roiId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a ROI in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {number} roiId A JSON object with the new ROI to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoiApi
     */
    public v1EditionsEditionIdRoisRoiIdGet(editionId: number, roiId: number, options?: any) {
        return RoiApiFp(this.configuration).v1EditionsEditionIdRoisRoiIdGet(editionId, roiId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing sign ROI in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {number} roiId Id of the ROI to be updated
     * @param {SetInterpretationRoiDTO} [setInterpretationRoiDTO] A JSON object with the updated ROI details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoiApi
     */
    public v1EditionsEditionIdRoisRoiIdPut(editionId: number, roiId: number, setInterpretationRoiDTO?: SetInterpretationRoiDTO, options?: any) {
        return RoiApiFp(this.configuration).v1EditionsEditionIdRoisRoiIdPut(editionId, roiId, setInterpretationRoiDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SignInterpretationApi - axios parameter creator
 * @export
 */
export const SignInterpretationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an attribute from an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {number} attributeId The ID of the attribute to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete: async (editionId: number, attributeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete.');
            }
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new RequiredError('attributeId','Required parameter attributeId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the details of an attribute in an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {number} attributeId The ID of the attribute to update
         * @param {UpdateAttributeDTO} [updateAttributeDTO] The details of the updated attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut: async (editionId: number, attributeId: number, updateAttributeDTO?: UpdateAttributeDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut.');
            }
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new RequiredError('attributeId','Required parameter attributeId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAttributeDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAttributeDTO !== undefined ? updateAttributeDTO : {}) : (updateAttributeDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of all possible attributes for an edition
         * @param {number} editionId The ID of the edition being searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesGet: async (editionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations-attributes`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new attribute for an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {CreateAttributeDTO} [createAttributeDTO] The details of the new attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesPost: async (editionId: number, createAttributeDTO?: CreateAttributeDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsAttributesPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations-attributes`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createAttributeDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAttributeDTO !== undefined ? createAttributeDTO : {}) : (createAttributeDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new sign interpretation
         * @param {number} editionId ID of the edition being changed
         * @param {SignInterpretationCreateDTO} [signInterpretationCreateDTO] New sign interpretation data to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsPost: async (editionId: number, signInterpretationCreateDTO?: SignInterpretationCreateDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof signInterpretationCreateDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(signInterpretationCreateDTO !== undefined ? signInterpretationCreateDTO : {}) : (signInterpretationCreateDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This deletes the specified attribute value from the specified sign interpretation.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being altered
         * @param {number} attributeValueId Id of the attribute being removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete: async (editionId: number, signInterpretationId: number, attributeValueId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete.');
            }
            // verify required parameter 'attributeValueId' is not null or undefined
            if (attributeValueId === null || attributeValueId === undefined) {
                throw new RequiredError('attributeValueId','Required parameter attributeValueId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)))
                .replace(`{${"attributeValueId"}}`, encodeURIComponent(String(attributeValueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being altered
         * @param {number} attributeValueId Id of the attribute value to be altered
         * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] New details of the attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut: async (editionId: number, signInterpretationId: number, attributeValueId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut.');
            }
            // verify required parameter 'attributeValueId' is not null or undefined
            if (attributeValueId === null || attributeValueId === undefined) {
                throw new RequiredError('attributeValueId','Required parameter attributeValueId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)))
                .replace(`{${"attributeValueId"}}`, encodeURIComponent(String(attributeValueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof interpretationAttributeCreateDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(interpretationAttributeCreateDTO !== undefined ? interpretationAttributeCreateDTO : {}) : (interpretationAttributeCreateDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This adds a new attribute to the specified sign interpretation.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation for adding a new attribute
         * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] Details of the attribute to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost: async (editionId: number, signInterpretationId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof interpretationAttributeCreateDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(interpretationAttributeCreateDTO !== undefined ? interpretationAttributeCreateDTO : {}) : (interpretationAttributeCreateDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the commentary of a sign interpretation
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation whose commentary is being changed
         * @param {CommentaryCreateDTO} [commentaryCreateDTO] The new commentary for the sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut: async (editionId: number, signInterpretationId: number, commentaryCreateDTO?: CommentaryCreateDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/commentary`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof commentaryCreateDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(commentaryCreateDTO !== undefined ? commentaryCreateDTO : {}) : (commentaryCreateDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign\'s next and previous nodes.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete: async (editionId: number, signInterpretationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the details of a sign interpretation in an edition
         * @param {number} editionId The ID of the edition being searched
         * @param {number} signInterpretationId The desired sign interpretation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet: async (editionId: number, signInterpretationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Links two sign interpretations in the edition\'s sign stream
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId The sign interpretation to be linked to the nextSignInterpretationId
         * @param {number} nextSignInterpretationId The sign interpretation to become the new next sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost: async (editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost.');
            }
            // verify required parameter 'nextSignInterpretationId' is not null or undefined
            if (nextSignInterpretationId === null || nextSignInterpretationId === undefined) {
                throw new RequiredError('nextSignInterpretationId','Required parameter nextSignInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/link-to/{nextSignInterpretationId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)))
                .replace(`{${"nextSignInterpretationId"}}`, encodeURIComponent(String(nextSignInterpretationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Links two sign interpretations in the edition\'s sign stream
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId The sign interpretation to be unlinked from the nextSignInterpretationId
         * @param {number} nextSignInterpretationId The sign interpretation to removed as next sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost: async (editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost.');
            }
            // verify required parameter 'signInterpretationId' is not null or undefined
            if (signInterpretationId === null || signInterpretationId === undefined) {
                throw new RequiredError('signInterpretationId','Required parameter signInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost.');
            }
            // verify required parameter 'nextSignInterpretationId' is not null or undefined
            if (nextSignInterpretationId === null || nextSignInterpretationId === undefined) {
                throw new RequiredError('nextSignInterpretationId','Required parameter nextSignInterpretationId was null or undefined when calling v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/unlink-from/{nextSignInterpretationId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"signInterpretationId"}}`, encodeURIComponent(String(signInterpretationId)))
                .replace(`{${"nextSignInterpretationId"}}`, encodeURIComponent(String(nextSignInterpretationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignInterpretationApi - functional programming interface
 * @export
 */
export const SignInterpretationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an attribute from an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {number} attributeId The ID of the attribute to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(editionId: number, attributeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(editionId, attributeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Change the details of an attribute in an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {number} attributeId The ID of the attribute to update
         * @param {UpdateAttributeDTO} [updateAttributeDTO] The details of the updated attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(editionId: number, attributeId: number, updateAttributeDTO?: UpdateAttributeDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(editionId, attributeId, updateAttributeDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a list of all possible attributes for an edition
         * @param {number} editionId The ID of the edition being searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsAttributesGet(editionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeListDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsAttributesGet(editionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new attribute for an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {CreateAttributeDTO} [createAttributeDTO] The details of the new attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsAttributesPost(editionId: number, createAttributeDTO?: CreateAttributeDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsAttributesPost(editionId, createAttributeDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new sign interpretation
         * @param {number} editionId ID of the edition being changed
         * @param {SignInterpretationCreateDTO} [signInterpretationCreateDTO] New sign interpretation data to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsPost(editionId: number, signInterpretationCreateDTO?: SignInterpretationCreateDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInterpretationListDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsPost(editionId, signInterpretationCreateDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary This deletes the specified attribute value from the specified sign interpretation.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being altered
         * @param {number} attributeValueId Id of the attribute being removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(editionId: number, signInterpretationId: number, attributeValueId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(editionId, signInterpretationId, attributeValueId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being altered
         * @param {number} attributeValueId Id of the attribute value to be altered
         * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] New details of the attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(editionId: number, signInterpretationId: number, attributeValueId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInterpretationDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(editionId, signInterpretationId, attributeValueId, interpretationAttributeCreateDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary This adds a new attribute to the specified sign interpretation.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation for adding a new attribute
         * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] Details of the attribute to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(editionId: number, signInterpretationId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInterpretationDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(editionId, signInterpretationId, interpretationAttributeCreateDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the commentary of a sign interpretation
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation whose commentary is being changed
         * @param {CommentaryCreateDTO} [commentaryCreateDTO] The new commentary for the sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(editionId: number, signInterpretationId: number, commentaryCreateDTO?: CommentaryCreateDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInterpretationDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(editionId, signInterpretationId, commentaryCreateDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign\'s next and previous nodes.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(editionId: number, signInterpretationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(editionId, signInterpretationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the details of a sign interpretation in an edition
         * @param {number} editionId The ID of the edition being searched
         * @param {number} signInterpretationId The desired sign interpretation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(editionId: number, signInterpretationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInterpretationDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(editionId, signInterpretationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Links two sign interpretations in the edition\'s sign stream
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId The sign interpretation to be linked to the nextSignInterpretationId
         * @param {number} nextSignInterpretationId The sign interpretation to become the new next sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInterpretationDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(editionId, signInterpretationId, nextSignInterpretationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Links two sign interpretations in the edition\'s sign stream
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId The sign interpretation to be unlinked from the nextSignInterpretationId
         * @param {number} nextSignInterpretationId The sign interpretation to removed as next sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInterpretationDTO>> {
            const localVarAxiosArgs = await SignInterpretationApiAxiosParamCreator(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(editionId, signInterpretationId, nextSignInterpretationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SignInterpretationApi - factory interface
 * @export
 */
export const SignInterpretationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete an attribute from an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {number} attributeId The ID of the attribute to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(editionId: number, attributeId: number, options?: any): AxiosPromise<void> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(editionId, attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the details of an attribute in an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {number} attributeId The ID of the attribute to update
         * @param {UpdateAttributeDTO} [updateAttributeDTO] The details of the updated attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(editionId: number, attributeId: number, updateAttributeDTO?: UpdateAttributeDTO, options?: any): AxiosPromise<AttributeDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(editionId, attributeId, updateAttributeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of all possible attributes for an edition
         * @param {number} editionId The ID of the edition being searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesGet(editionId: number, options?: any): AxiosPromise<AttributeListDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsAttributesGet(editionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new attribute for an edition
         * @param {number} editionId The ID of the edition being edited
         * @param {CreateAttributeDTO} [createAttributeDTO] The details of the new attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsAttributesPost(editionId: number, createAttributeDTO?: CreateAttributeDTO, options?: any): AxiosPromise<AttributeDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsAttributesPost(editionId, createAttributeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new sign interpretation
         * @param {number} editionId ID of the edition being changed
         * @param {SignInterpretationCreateDTO} [signInterpretationCreateDTO] New sign interpretation data to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsPost(editionId: number, signInterpretationCreateDTO?: SignInterpretationCreateDTO, options?: any): AxiosPromise<SignInterpretationListDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsPost(editionId, signInterpretationCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This deletes the specified attribute value from the specified sign interpretation.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being altered
         * @param {number} attributeValueId Id of the attribute being removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(editionId: number, signInterpretationId: number, attributeValueId: number, options?: any): AxiosPromise<void> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(editionId, signInterpretationId, attributeValueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being altered
         * @param {number} attributeValueId Id of the attribute value to be altered
         * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] New details of the attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(editionId: number, signInterpretationId: number, attributeValueId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options?: any): AxiosPromise<SignInterpretationDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(editionId, signInterpretationId, attributeValueId, interpretationAttributeCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This adds a new attribute to the specified sign interpretation.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation for adding a new attribute
         * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] Details of the attribute to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(editionId: number, signInterpretationId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options?: any): AxiosPromise<SignInterpretationDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(editionId, signInterpretationId, interpretationAttributeCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the commentary of a sign interpretation
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation whose commentary is being changed
         * @param {CommentaryCreateDTO} [commentaryCreateDTO] The new commentary for the sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(editionId: number, signInterpretationId: number, commentaryCreateDTO?: CommentaryCreateDTO, options?: any): AxiosPromise<SignInterpretationDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(editionId, signInterpretationId, commentaryCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign\'s next and previous nodes.
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId ID of the sign interpretation being deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(editionId: number, signInterpretationId: number, options?: any): AxiosPromise<void> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(editionId, signInterpretationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the details of a sign interpretation in an edition
         * @param {number} editionId The ID of the edition being searched
         * @param {number} signInterpretationId The desired sign interpretation id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(editionId: number, signInterpretationId: number, options?: any): AxiosPromise<SignInterpretationDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(editionId, signInterpretationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Links two sign interpretations in the edition\'s sign stream
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId The sign interpretation to be linked to the nextSignInterpretationId
         * @param {number} nextSignInterpretationId The sign interpretation to become the new next sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options?: any): AxiosPromise<SignInterpretationDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(editionId, signInterpretationId, nextSignInterpretationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Links two sign interpretations in the edition\'s sign stream
         * @param {number} editionId ID of the edition being changed
         * @param {number} signInterpretationId The sign interpretation to be unlinked from the nextSignInterpretationId
         * @param {number} nextSignInterpretationId The sign interpretation to removed as next sign interpretation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options?: any): AxiosPromise<SignInterpretationDTO> {
            return SignInterpretationApiFp(configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(editionId, signInterpretationId, nextSignInterpretationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignInterpretationApi - object-oriented interface
 * @export
 * @class SignInterpretationApi
 * @extends {BaseAPI}
 */
export class SignInterpretationApi extends BaseAPI {
    /**
     * 
     * @summary Delete an attribute from an edition
     * @param {number} editionId The ID of the edition being edited
     * @param {number} attributeId The ID of the attribute to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(editionId: number, attributeId: number, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(editionId, attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the details of an attribute in an edition
     * @param {number} editionId The ID of the edition being edited
     * @param {number} attributeId The ID of the attribute to update
     * @param {UpdateAttributeDTO} [updateAttributeDTO] The details of the updated attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(editionId: number, attributeId: number, updateAttributeDTO?: UpdateAttributeDTO, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(editionId, attributeId, updateAttributeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of all possible attributes for an edition
     * @param {number} editionId The ID of the edition being searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsAttributesGet(editionId: number, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsAttributesGet(editionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new attribute for an edition
     * @param {number} editionId The ID of the edition being edited
     * @param {CreateAttributeDTO} [createAttributeDTO] The details of the new attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsAttributesPost(editionId: number, createAttributeDTO?: CreateAttributeDTO, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsAttributesPost(editionId, createAttributeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new sign interpretation
     * @param {number} editionId ID of the edition being changed
     * @param {SignInterpretationCreateDTO} [signInterpretationCreateDTO] New sign interpretation data to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsPost(editionId: number, signInterpretationCreateDTO?: SignInterpretationCreateDTO, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsPost(editionId, signInterpretationCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This deletes the specified attribute value from the specified sign interpretation.
     * @param {number} editionId ID of the edition being changed
     * @param {number} signInterpretationId ID of the sign interpretation being altered
     * @param {number} attributeValueId Id of the attribute being removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(editionId: number, signInterpretationId: number, attributeValueId: number, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(editionId, signInterpretationId, attributeValueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
     * @param {number} editionId ID of the edition being changed
     * @param {number} signInterpretationId ID of the sign interpretation being altered
     * @param {number} attributeValueId Id of the attribute value to be altered
     * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] New details of the attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(editionId: number, signInterpretationId: number, attributeValueId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(editionId, signInterpretationId, attributeValueId, interpretationAttributeCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This adds a new attribute to the specified sign interpretation.
     * @param {number} editionId ID of the edition being changed
     * @param {number} signInterpretationId ID of the sign interpretation for adding a new attribute
     * @param {InterpretationAttributeCreateDTO} [interpretationAttributeCreateDTO] Details of the attribute to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(editionId: number, signInterpretationId: number, interpretationAttributeCreateDTO?: InterpretationAttributeCreateDTO, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(editionId, signInterpretationId, interpretationAttributeCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the commentary of a sign interpretation
     * @param {number} editionId ID of the edition being changed
     * @param {number} signInterpretationId ID of the sign interpretation whose commentary is being changed
     * @param {CommentaryCreateDTO} [commentaryCreateDTO] The new commentary for the sign interpretation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(editionId: number, signInterpretationId: number, commentaryCreateDTO?: CommentaryCreateDTO, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(editionId, signInterpretationId, commentaryCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign\'s next and previous nodes.
     * @param {number} editionId ID of the edition being changed
     * @param {number} signInterpretationId ID of the sign interpretation being deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(editionId: number, signInterpretationId: number, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(editionId, signInterpretationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the details of a sign interpretation in an edition
     * @param {number} editionId The ID of the edition being searched
     * @param {number} signInterpretationId The desired sign interpretation id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(editionId: number, signInterpretationId: number, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(editionId, signInterpretationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Links two sign interpretations in the edition\'s sign stream
     * @param {number} editionId ID of the edition being changed
     * @param {number} signInterpretationId The sign interpretation to be linked to the nextSignInterpretationId
     * @param {number} nextSignInterpretationId The sign interpretation to become the new next sign interpretation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(editionId, signInterpretationId, nextSignInterpretationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Links two sign interpretations in the edition\'s sign stream
     * @param {number} editionId ID of the edition being changed
     * @param {number} signInterpretationId The sign interpretation to be unlinked from the nextSignInterpretationId
     * @param {number} nextSignInterpretationId The sign interpretation to removed as next sign interpretation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInterpretationApi
     */
    public v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(editionId: number, signInterpretationId: number, nextSignInterpretationId: number, options?: any) {
        return SignInterpretationApiFp(this.configuration).v1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(editionId, signInterpretationId, nextSignInterpretationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TextApi - axios parameter creator
 * @export
 */
export const TextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves all signs and their data from the given line
         * @param {number} editionId Id of the edition
         * @param {number} lineId Id of the line
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdLinesLineIdGet: async (editionId: number, lineId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdLinesLineIdGet.');
            }
            // verify required parameter 'lineId' is not null or undefined
            if (lineId === null || lineId === undefined) {
                throw new RequiredError('lineId','Required parameter lineId was null or undefined when calling v1EditionsEditionIdLinesLineIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/lines/{lineId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the ids of all Fragments of all fragments in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsGet: async (editionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/text-fragments`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new text fragment in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {CreateTextFragmentDTO} [createTextFragmentDTO] A JSON object with the details of the new text fragment to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsPost: async (editionId: number, createTextFragmentDTO?: CreateTextFragmentDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsPost.');
            }
            const localVarPath = `/v1/editions/{editionId}/text-fragments`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createTextFragmentDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createTextFragmentDTO !== undefined ? createTextFragmentDTO : {}) : (createTextFragmentDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the ids of all Artefacts in the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet: async (editionId: number, textFragmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet.');
            }
            // verify required parameter 'textFragmentId' is not null or undefined
            if (textFragmentId === null || textFragmentId === undefined) {
                throw new RequiredError('textFragmentId','Required parameter textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/text-fragments/{textFragmentId}/artefacts`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"textFragmentId"}}`, encodeURIComponent(String(textFragmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all signs and their data from the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdGet: async (editionId: number, textFragmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdGet.');
            }
            // verify required parameter 'textFragmentId' is not null or undefined
            if (textFragmentId === null || textFragmentId === undefined) {
                throw new RequiredError('textFragmentId','Required parameter textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/text-fragments/{textFragmentId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"textFragmentId"}}`, encodeURIComponent(String(textFragmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the ids of all lines in the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet: async (editionId: number, textFragmentId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet.');
            }
            // verify required parameter 'textFragmentId' is not null or undefined
            if (textFragmentId === null || textFragmentId === undefined) {
                throw new RequiredError('textFragmentId','Required parameter textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet.');
            }
            const localVarPath = `/v1/editions/{editionId}/text-fragments/{textFragmentId}/lines`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"textFragmentId"}}`, encodeURIComponent(String(textFragmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the specified text fragment with the submitted properties
         * @param {number} editionId Edition of the text fragment being updates
         * @param {number} textFragmentId Id of the text fragment being updates
         * @param {UpdateTextFragmentDTO} [updateTextFragmentDTO] Details of the updated text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdPut: async (editionId: number, textFragmentId: number, updateTextFragmentDTO?: UpdateTextFragmentDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionId' is not null or undefined
            if (editionId === null || editionId === undefined) {
                throw new RequiredError('editionId','Required parameter editionId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdPut.');
            }
            // verify required parameter 'textFragmentId' is not null or undefined
            if (textFragmentId === null || textFragmentId === undefined) {
                throw new RequiredError('textFragmentId','Required parameter textFragmentId was null or undefined when calling v1EditionsEditionIdTextFragmentsTextFragmentIdPut.');
            }
            const localVarPath = `/v1/editions/{editionId}/text-fragments/{textFragmentId}`
                .replace(`{${"editionId"}}`, encodeURIComponent(String(editionId)))
                .replace(`{${"textFragmentId"}}`, encodeURIComponent(String(textFragmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateTextFragmentDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateTextFragmentDTO !== undefined ? updateTextFragmentDTO : {}) : (updateTextFragmentDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextApi - functional programming interface
 * @export
 */
export const TextApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves all signs and their data from the given line
         * @param {number} editionId Id of the edition
         * @param {number} lineId Id of the line
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdLinesLineIdGet(editionId: number, lineId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LineTextDTO>> {
            const localVarAxiosArgs = await TextApiAxiosParamCreator(configuration).v1EditionsEditionIdLinesLineIdGet(editionId, lineId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves the ids of all Fragments of all fragments in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdTextFragmentsGet(editionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextFragmentDataListDTO>> {
            const localVarAxiosArgs = await TextApiAxiosParamCreator(configuration).v1EditionsEditionIdTextFragmentsGet(editionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new text fragment in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {CreateTextFragmentDTO} [createTextFragmentDTO] A JSON object with the details of the new text fragment to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdTextFragmentsPost(editionId: number, createTextFragmentDTO?: CreateTextFragmentDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextFragmentDataDTO>> {
            const localVarAxiosArgs = await TextApiAxiosParamCreator(configuration).v1EditionsEditionIdTextFragmentsPost(editionId, createTextFragmentDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves the ids of all Artefacts in the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet(editionId: number, textFragmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactDataListDTO>> {
            const localVarAxiosArgs = await TextApiAxiosParamCreator(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet(editionId, textFragmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves all signs and their data from the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdTextFragmentsTextFragmentIdGet(editionId: number, textFragmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextEditionDTO>> {
            const localVarAxiosArgs = await TextApiAxiosParamCreator(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdGet(editionId, textFragmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves the ids of all lines in the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet(editionId: number, textFragmentId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LineDataListDTO>> {
            const localVarAxiosArgs = await TextApiAxiosParamCreator(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet(editionId, textFragmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the specified text fragment with the submitted properties
         * @param {number} editionId Edition of the text fragment being updates
         * @param {number} textFragmentId Id of the text fragment being updates
         * @param {UpdateTextFragmentDTO} [updateTextFragmentDTO] Details of the updated text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1EditionsEditionIdTextFragmentsTextFragmentIdPut(editionId: number, textFragmentId: number, updateTextFragmentDTO?: UpdateTextFragmentDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextFragmentDataDTO>> {
            const localVarAxiosArgs = await TextApiAxiosParamCreator(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdPut(editionId, textFragmentId, updateTextFragmentDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextApi - factory interface
 * @export
 */
export const TextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieves all signs and their data from the given line
         * @param {number} editionId Id of the edition
         * @param {number} lineId Id of the line
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdLinesLineIdGet(editionId: number, lineId: number, options?: any): AxiosPromise<LineTextDTO> {
            return TextApiFp(configuration).v1EditionsEditionIdLinesLineIdGet(editionId, lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the ids of all Fragments of all fragments in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsGet(editionId: number, options?: any): AxiosPromise<TextFragmentDataListDTO> {
            return TextApiFp(configuration).v1EditionsEditionIdTextFragmentsGet(editionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new text fragment in the given edition of a scroll
         * @param {number} editionId Id of the edition
         * @param {CreateTextFragmentDTO} [createTextFragmentDTO] A JSON object with the details of the new text fragment to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsPost(editionId: number, createTextFragmentDTO?: CreateTextFragmentDTO, options?: any): AxiosPromise<TextFragmentDataDTO> {
            return TextApiFp(configuration).v1EditionsEditionIdTextFragmentsPost(editionId, createTextFragmentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the ids of all Artefacts in the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet(editionId: number, textFragmentId: number, options?: any): AxiosPromise<ArtefactDataListDTO> {
            return TextApiFp(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet(editionId, textFragmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all signs and their data from the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdGet(editionId: number, textFragmentId: number, options?: any): AxiosPromise<TextEditionDTO> {
            return TextApiFp(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdGet(editionId, textFragmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the ids of all lines in the given textFragmentName
         * @param {number} editionId Id of the edition
         * @param {number} textFragmentId Id of the text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet(editionId: number, textFragmentId: number, options?: any): AxiosPromise<LineDataListDTO> {
            return TextApiFp(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet(editionId, textFragmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the specified text fragment with the submitted properties
         * @param {number} editionId Edition of the text fragment being updates
         * @param {number} textFragmentId Id of the text fragment being updates
         * @param {UpdateTextFragmentDTO} [updateTextFragmentDTO] Details of the updated text fragment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1EditionsEditionIdTextFragmentsTextFragmentIdPut(editionId: number, textFragmentId: number, updateTextFragmentDTO?: UpdateTextFragmentDTO, options?: any): AxiosPromise<TextFragmentDataDTO> {
            return TextApiFp(configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdPut(editionId, textFragmentId, updateTextFragmentDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextApi - object-oriented interface
 * @export
 * @class TextApi
 * @extends {BaseAPI}
 */
export class TextApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves all signs and their data from the given line
     * @param {number} editionId Id of the edition
     * @param {number} lineId Id of the line
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextApi
     */
    public v1EditionsEditionIdLinesLineIdGet(editionId: number, lineId: number, options?: any) {
        return TextApiFp(this.configuration).v1EditionsEditionIdLinesLineIdGet(editionId, lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the ids of all Fragments of all fragments in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextApi
     */
    public v1EditionsEditionIdTextFragmentsGet(editionId: number, options?: any) {
        return TextApiFp(this.configuration).v1EditionsEditionIdTextFragmentsGet(editionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new text fragment in the given edition of a scroll
     * @param {number} editionId Id of the edition
     * @param {CreateTextFragmentDTO} [createTextFragmentDTO] A JSON object with the details of the new text fragment to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextApi
     */
    public v1EditionsEditionIdTextFragmentsPost(editionId: number, createTextFragmentDTO?: CreateTextFragmentDTO, options?: any) {
        return TextApiFp(this.configuration).v1EditionsEditionIdTextFragmentsPost(editionId, createTextFragmentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the ids of all Artefacts in the given textFragmentName
     * @param {number} editionId Id of the edition
     * @param {number} textFragmentId Id of the text fragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextApi
     */
    public v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet(editionId: number, textFragmentId: number, options?: any) {
        return TextApiFp(this.configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdArtefactsGet(editionId, textFragmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all signs and their data from the given textFragmentName
     * @param {number} editionId Id of the edition
     * @param {number} textFragmentId Id of the text fragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextApi
     */
    public v1EditionsEditionIdTextFragmentsTextFragmentIdGet(editionId: number, textFragmentId: number, options?: any) {
        return TextApiFp(this.configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdGet(editionId, textFragmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the ids of all lines in the given textFragmentName
     * @param {number} editionId Id of the edition
     * @param {number} textFragmentId Id of the text fragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextApi
     */
    public v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet(editionId: number, textFragmentId: number, options?: any) {
        return TextApiFp(this.configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdLinesGet(editionId, textFragmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the specified text fragment with the submitted properties
     * @param {number} editionId Edition of the text fragment being updates
     * @param {number} textFragmentId Id of the text fragment being updates
     * @param {UpdateTextFragmentDTO} [updateTextFragmentDTO] Details of the updated text fragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextApi
     */
    public v1EditionsEditionIdTextFragmentsTextFragmentIdPut(editionId: number, textFragmentId: number, updateTextFragmentDTO?: UpdateTextFragmentDTO, options?: any) {
        return TextApiFp(this.configuration).v1EditionsEditionIdTextFragmentsTextFragmentIdPut(editionId, textFragmentId, updateTextFragmentDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Uses the secret token from /users/forgot-password to validate a reset of the user\'s password
         * @param {ResetForgottenUserPasswordRequestDTO} [resetForgottenUserPasswordRequestDTO] A JSON object with the secret token and the new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersChangeForgottenPasswordPost: async (resetForgottenUserPasswordRequestDTO?: ResetForgottenUserPasswordRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/change-forgotten-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resetForgottenUserPasswordRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resetForgottenUserPasswordRequestDTO !== undefined ? resetForgottenUserPasswordRequestDTO : {}) : (resetForgottenUserPasswordRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Changes the password for the currently logged in user
         * @param {ResetLoggedInUserPasswordRequestDTO} [resetLoggedInUserPasswordRequestDTO] A JSON object with the old password and the new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersChangePasswordPost: async (resetLoggedInUserPasswordRequestDTO?: ResetLoggedInUserPasswordRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resetLoggedInUserPasswordRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resetLoggedInUserPasswordRequestDTO !== undefined ? resetLoggedInUserPasswordRequestDTO : {}) : (resetLoggedInUserPasswordRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allows a user who has not yet activated their account to change their email address. This will not work if the user  account associated with the email address has already been activated
         * @param {UnactivatedEmailUpdateRequestDTO} [unactivatedEmailUpdateRequestDTO] JSON object with the current email address and the new desired email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersChangeUnactivatedEmailPost: async (unactivatedEmailUpdateRequestDTO?: UnactivatedEmailUpdateRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/change-unactivated-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof unactivatedEmailUpdateRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(unactivatedEmailUpdateRequestDTO !== undefined ? unactivatedEmailUpdateRequestDTO : {}) : (unactivatedEmailUpdateRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirms registration of new user account.
         * @param {AccountActivationRequestDTO} [accountActivationRequestDTO] JSON object with token from user registration email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersConfirmRegistrationPost: async (accountActivationRequestDTO?: AccountActivationRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/confirm-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof accountActivationRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accountActivationRequestDTO !== undefined ? accountActivationRequestDTO : {}) : (accountActivationRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends a secret token to the user\'s email to allow password reset.
         * @param {ResetUserPasswordRequestDTO} [resetUserPasswordRequestDTO] JSON object with the email address for the user who wants to reset a lost password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersForgotPasswordPost: async (resetUserPasswordRequestDTO?: ResetUserPasswordRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resetUserPasswordRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resetUserPasswordRequestDTO !== undefined ? resetUserPasswordRequestDTO : {}) : (resetUserPasswordRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides the user details for a user with valid JWT in the Authorize header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a JWT bearer token for valid email and password
         * @param {LoginRequestDTO} [loginRequestDTO] JSON object with an email and password parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersLoginPost: async (loginRequestDTO?: LoginRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof loginRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(loginRequestDTO !== undefined ? loginRequestDTO : {}) : (loginRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new user with the submitted data.
         * @param {NewUserRequestDTO} [newUserRequestDTO] A JSON object with all data necessary to create a new user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersPost: async (newUserRequestDTO?: NewUserRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof newUserRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newUserRequestDTO !== undefined ? newUserRequestDTO : {}) : (newUserRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s registration details.  Note that the if the email address has changed, the account will be set to  inactive until the account is activated with the secret token.
         * @param {UserUpdateRequestDTO} [userUpdateRequestDTO] A JSON object with all data necessary to update a user account.  Null fields (but not empty  strings!) will be populated with existing user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersPut: async (userUpdateRequestDTO?: UserUpdateRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userUpdateRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userUpdateRequestDTO !== undefined ? userUpdateRequestDTO : {}) : (userUpdateRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends a new activation email for the user\'s account. This will not work if the user account associated with the  email address has already been activated.
         * @param {ResendUserAccountActivationRequestDTO} [resendUserAccountActivationRequestDTO] JSON object with the current email address and the new desired email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersResendActivationEmailPost: async (resendUserAccountActivationRequestDTO?: ResendUserAccountActivationRequestDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/resend-activation-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resendUserAccountActivationRequestDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resendUserAccountActivationRequestDTO !== undefined ? resendUserAccountActivationRequestDTO : {}) : (resendUserAccountActivationRequestDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Uses the secret token from /users/forgot-password to validate a reset of the user\'s password
         * @param {ResetForgottenUserPasswordRequestDTO} [resetForgottenUserPasswordRequestDTO] A JSON object with the secret token and the new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersChangeForgottenPasswordPost(resetForgottenUserPasswordRequestDTO?: ResetForgottenUserPasswordRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersChangeForgottenPasswordPost(resetForgottenUserPasswordRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Changes the password for the currently logged in user
         * @param {ResetLoggedInUserPasswordRequestDTO} [resetLoggedInUserPasswordRequestDTO] A JSON object with the old password and the new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersChangePasswordPost(resetLoggedInUserPasswordRequestDTO?: ResetLoggedInUserPasswordRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersChangePasswordPost(resetLoggedInUserPasswordRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Allows a user who has not yet activated their account to change their email address. This will not work if the user  account associated with the email address has already been activated
         * @param {UnactivatedEmailUpdateRequestDTO} [unactivatedEmailUpdateRequestDTO] JSON object with the current email address and the new desired email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersChangeUnactivatedEmailPost(unactivatedEmailUpdateRequestDTO?: UnactivatedEmailUpdateRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersChangeUnactivatedEmailPost(unactivatedEmailUpdateRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Confirms registration of new user account.
         * @param {AccountActivationRequestDTO} [accountActivationRequestDTO] JSON object with token from user registration email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersConfirmRegistrationPost(accountActivationRequestDTO?: AccountActivationRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersConfirmRegistrationPost(accountActivationRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sends a secret token to the user\'s email to allow password reset.
         * @param {ResetUserPasswordRequestDTO} [resetUserPasswordRequestDTO] JSON object with the email address for the user who wants to reset a lost password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersForgotPasswordPost(resetUserPasswordRequestDTO?: ResetUserPasswordRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersForgotPasswordPost(resetUserPasswordRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides the user details for a user with valid JWT in the Authorize header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Provides a JWT bearer token for valid email and password
         * @param {LoginRequestDTO} [loginRequestDTO] JSON object with an email and password parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersLoginPost(loginRequestDTO?: LoginRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedUserTokenDTO>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersLoginPost(loginRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new user with the submitted data.
         * @param {NewUserRequestDTO} [newUserRequestDTO] A JSON object with all data necessary to create a new user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersPost(newUserRequestDTO?: NewUserRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersPost(newUserRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user\'s registration details.  Note that the if the email address has changed, the account will be set to  inactive until the account is activated with the secret token.
         * @param {UserUpdateRequestDTO} [userUpdateRequestDTO] A JSON object with all data necessary to update a user account.  Null fields (but not empty  strings!) will be populated with existing user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersPut(userUpdateRequestDTO?: UserUpdateRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedUserDTO>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersPut(userUpdateRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sends a new activation email for the user\'s account. This will not work if the user account associated with the  email address has already been activated.
         * @param {ResendUserAccountActivationRequestDTO} [resendUserAccountActivationRequestDTO] JSON object with the current email address and the new desired email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersResendActivationEmailPost(resendUserAccountActivationRequestDTO?: ResendUserAccountActivationRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).v1UsersResendActivationEmailPost(resendUserAccountActivationRequestDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Uses the secret token from /users/forgot-password to validate a reset of the user\'s password
         * @param {ResetForgottenUserPasswordRequestDTO} [resetForgottenUserPasswordRequestDTO] A JSON object with the secret token and the new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersChangeForgottenPasswordPost(resetForgottenUserPasswordRequestDTO?: ResetForgottenUserPasswordRequestDTO, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).v1UsersChangeForgottenPasswordPost(resetForgottenUserPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Changes the password for the currently logged in user
         * @param {ResetLoggedInUserPasswordRequestDTO} [resetLoggedInUserPasswordRequestDTO] A JSON object with the old password and the new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersChangePasswordPost(resetLoggedInUserPasswordRequestDTO?: ResetLoggedInUserPasswordRequestDTO, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).v1UsersChangePasswordPost(resetLoggedInUserPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allows a user who has not yet activated their account to change their email address. This will not work if the user  account associated with the email address has already been activated
         * @param {UnactivatedEmailUpdateRequestDTO} [unactivatedEmailUpdateRequestDTO] JSON object with the current email address and the new desired email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersChangeUnactivatedEmailPost(unactivatedEmailUpdateRequestDTO?: UnactivatedEmailUpdateRequestDTO, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).v1UsersChangeUnactivatedEmailPost(unactivatedEmailUpdateRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirms registration of new user account.
         * @param {AccountActivationRequestDTO} [accountActivationRequestDTO] JSON object with token from user registration email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersConfirmRegistrationPost(accountActivationRequestDTO?: AccountActivationRequestDTO, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).v1UsersConfirmRegistrationPost(accountActivationRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends a secret token to the user\'s email to allow password reset.
         * @param {ResetUserPasswordRequestDTO} [resetUserPasswordRequestDTO] JSON object with the email address for the user who wants to reset a lost password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersForgotPasswordPost(resetUserPasswordRequestDTO?: ResetUserPasswordRequestDTO, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).v1UsersForgotPasswordPost(resetUserPasswordRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides the user details for a user with valid JWT in the Authorize header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersGet(options?: any): AxiosPromise<UserDTO> {
            return UserApiFp(configuration).v1UsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provides a JWT bearer token for valid email and password
         * @param {LoginRequestDTO} [loginRequestDTO] JSON object with an email and password parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersLoginPost(loginRequestDTO?: LoginRequestDTO, options?: any): AxiosPromise<DetailedUserTokenDTO> {
            return UserApiFp(configuration).v1UsersLoginPost(loginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new user with the submitted data.
         * @param {NewUserRequestDTO} [newUserRequestDTO] A JSON object with all data necessary to create a new user account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersPost(newUserRequestDTO?: NewUserRequestDTO, options?: any): AxiosPromise<UserDTO> {
            return UserApiFp(configuration).v1UsersPost(newUserRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s registration details.  Note that the if the email address has changed, the account will be set to  inactive until the account is activated with the secret token.
         * @param {UserUpdateRequestDTO} [userUpdateRequestDTO] A JSON object with all data necessary to update a user account.  Null fields (but not empty  strings!) will be populated with existing user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersPut(userUpdateRequestDTO?: UserUpdateRequestDTO, options?: any): AxiosPromise<DetailedUserDTO> {
            return UserApiFp(configuration).v1UsersPut(userUpdateRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends a new activation email for the user\'s account. This will not work if the user account associated with the  email address has already been activated.
         * @param {ResendUserAccountActivationRequestDTO} [resendUserAccountActivationRequestDTO] JSON object with the current email address and the new desired email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersResendActivationEmailPost(resendUserAccountActivationRequestDTO?: ResendUserAccountActivationRequestDTO, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).v1UsersResendActivationEmailPost(resendUserAccountActivationRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Uses the secret token from /users/forgot-password to validate a reset of the user\'s password
     * @param {ResetForgottenUserPasswordRequestDTO} [resetForgottenUserPasswordRequestDTO] A JSON object with the secret token and the new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersChangeForgottenPasswordPost(resetForgottenUserPasswordRequestDTO?: ResetForgottenUserPasswordRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersChangeForgottenPasswordPost(resetForgottenUserPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Changes the password for the currently logged in user
     * @param {ResetLoggedInUserPasswordRequestDTO} [resetLoggedInUserPasswordRequestDTO] A JSON object with the old password and the new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersChangePasswordPost(resetLoggedInUserPasswordRequestDTO?: ResetLoggedInUserPasswordRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersChangePasswordPost(resetLoggedInUserPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allows a user who has not yet activated their account to change their email address. This will not work if the user  account associated with the email address has already been activated
     * @param {UnactivatedEmailUpdateRequestDTO} [unactivatedEmailUpdateRequestDTO] JSON object with the current email address and the new desired email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersChangeUnactivatedEmailPost(unactivatedEmailUpdateRequestDTO?: UnactivatedEmailUpdateRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersChangeUnactivatedEmailPost(unactivatedEmailUpdateRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirms registration of new user account.
     * @param {AccountActivationRequestDTO} [accountActivationRequestDTO] JSON object with token from user registration email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersConfirmRegistrationPost(accountActivationRequestDTO?: AccountActivationRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersConfirmRegistrationPost(accountActivationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends a secret token to the user\'s email to allow password reset.
     * @param {ResetUserPasswordRequestDTO} [resetUserPasswordRequestDTO] JSON object with the email address for the user who wants to reset a lost password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersForgotPasswordPost(resetUserPasswordRequestDTO?: ResetUserPasswordRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersForgotPasswordPost(resetUserPasswordRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides the user details for a user with valid JWT in the Authorize header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersGet(options?: any) {
        return UserApiFp(this.configuration).v1UsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provides a JWT bearer token for valid email and password
     * @param {LoginRequestDTO} [loginRequestDTO] JSON object with an email and password parameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersLoginPost(loginRequestDTO?: LoginRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersLoginPost(loginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new user with the submitted data.
     * @param {NewUserRequestDTO} [newUserRequestDTO] A JSON object with all data necessary to create a new user account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersPost(newUserRequestDTO?: NewUserRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersPost(newUserRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s registration details.  Note that the if the email address has changed, the account will be set to  inactive until the account is activated with the secret token.
     * @param {UserUpdateRequestDTO} [userUpdateRequestDTO] A JSON object with all data necessary to update a user account.  Null fields (but not empty  strings!) will be populated with existing user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersPut(userUpdateRequestDTO?: UserUpdateRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersPut(userUpdateRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends a new activation email for the user\'s account. This will not work if the user account associated with the  email address has already been activated.
     * @param {ResendUserAccountActivationRequestDTO} [resendUserAccountActivationRequestDTO] JSON object with the current email address and the new desired email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UsersResendActivationEmailPost(resendUserAccountActivationRequestDTO?: ResendUserAccountActivationRequestDTO, options?: any) {
        return UserApiFp(this.configuration).v1UsersResendActivationEmailPost(resendUserAccountActivationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UtilApi - axios parameter creator
 * @export
 */
export const UtilApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks a WKT polygon to ensure validity. If the polygon is invalid,  it attempts to construct a valid polygon that matches the original  as closely as possible.
         * @param {WktPolygonDTO} [wktPolygonDTO] JSON object with the WKT polygon to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UtilsRepairWktPolygonPost: async (wktPolygonDTO?: WktPolygonDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/utils/repair-wkt-polygon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof wktPolygonDTO !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(wktPolygonDTO !== undefined ? wktPolygonDTO : {}) : (wktPolygonDTO || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilApi - functional programming interface
 * @export
 */
export const UtilApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks a WKT polygon to ensure validity. If the polygon is invalid,  it attempts to construct a valid polygon that matches the original  as closely as possible.
         * @param {WktPolygonDTO} [wktPolygonDTO] JSON object with the WKT polygon to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UtilsRepairWktPolygonPost(wktPolygonDTO?: WktPolygonDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WktPolygonDTO>> {
            const localVarAxiosArgs = await UtilApiAxiosParamCreator(configuration).v1UtilsRepairWktPolygonPost(wktPolygonDTO, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UtilApi - factory interface
 * @export
 */
export const UtilApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Checks a WKT polygon to ensure validity. If the polygon is invalid,  it attempts to construct a valid polygon that matches the original  as closely as possible.
         * @param {WktPolygonDTO} [wktPolygonDTO] JSON object with the WKT polygon to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UtilsRepairWktPolygonPost(wktPolygonDTO?: WktPolygonDTO, options?: any): AxiosPromise<WktPolygonDTO> {
            return UtilApiFp(configuration).v1UtilsRepairWktPolygonPost(wktPolygonDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilApi - object-oriented interface
 * @export
 * @class UtilApi
 * @extends {BaseAPI}
 */
export class UtilApi extends BaseAPI {
    /**
     * 
     * @summary Checks a WKT polygon to ensure validity. If the polygon is invalid,  it attempts to construct a valid polygon that matches the original  as closely as possible.
     * @param {WktPolygonDTO} [wktPolygonDTO] JSON object with the WKT polygon to validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilApi
     */
    public v1UtilsRepairWktPolygonPost(wktPolygonDTO?: WktPolygonDTO, options?: any) {
        return UtilApiFp(this.configuration).v1UtilsRepairWktPolygonPost(wktPolygonDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


