/**
 * SQE API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import CatalogueMatchInputDTO from '../model/CatalogueMatchInputDTO';
import CatalogueMatchListDTO from '../model/CatalogueMatchListDTO';

/**
* Catalogue service.
* @module api/CatalogueApi
* @version 0.7.0
*/
export default class CatalogueApi {

    /**
    * Constructs a new CatalogueApi. 
    * @alias module:api/CatalogueApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Remove an existing imaged object and text fragment match, which is not correct
     * @param {Number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDeleteWithHttpInfo(iaaEditionCatalogToTextFragmentId) {
      let postBody = null;
      // verify the required parameter 'iaaEditionCatalogToTextFragmentId' is set
      if (iaaEditionCatalogToTextFragmentId === undefined || iaaEditionCatalogToTextFragmentId === null) {
        throw new Error("Missing the required parameter 'iaaEditionCatalogToTextFragmentId' when calling v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete");
      }

      let pathParams = {
        'iaaEditionCatalogToTextFragmentId': iaaEditionCatalogToTextFragmentId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['Bearer'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/catalogue/confirm-match/{iaaEditionCatalogToTextFragmentId}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Remove an existing imaged object and text fragment match, which is not correct
     * @param {Number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDelete(iaaEditionCatalogToTextFragmentId) {
      return this.v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdDeleteWithHttpInfo(iaaEditionCatalogToTextFragmentId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Confirm the correctness of an existing imaged object and text fragment match
     * @param {Number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPostWithHttpInfo(iaaEditionCatalogToTextFragmentId) {
      let postBody = null;
      // verify the required parameter 'iaaEditionCatalogToTextFragmentId' is set
      if (iaaEditionCatalogToTextFragmentId === undefined || iaaEditionCatalogToTextFragmentId === null) {
        throw new Error("Missing the required parameter 'iaaEditionCatalogToTextFragmentId' when calling v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost");
      }

      let pathParams = {
        'iaaEditionCatalogToTextFragmentId': iaaEditionCatalogToTextFragmentId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['Bearer'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/catalogue/confirm-match/{iaaEditionCatalogToTextFragmentId}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Confirm the correctness of an existing imaged object and text fragment match
     * @param {Number} iaaEditionCatalogToTextFragmentId The unique id of the match to confirm
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPost(iaaEditionCatalogToTextFragmentId) {
      return this.v1CatalogueConfirmMatchIaaEditionCatalogToTextFragmentIdPostWithHttpInfo(iaaEditionCatalogToTextFragmentId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a listing of all corresponding imaged objects and transcribed text fragment in a specified edition
     * @param {Number} editionId Unique Id of the edition to search for imaged objects to text fragment matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CatalogueMatchListDTO} and HTTP response
     */
    v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGetWithHttpInfo(editionId) {
      let postBody = null;
      // verify the required parameter 'editionId' is set
      if (editionId === undefined || editionId === null) {
        throw new Error("Missing the required parameter 'editionId' when calling v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet");
      }

      let pathParams = {
        'editionId': editionId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['Bearer'];
      let contentTypes = [];
      let accepts = ['text/plain', 'application/json', 'text/json'];
      let returnType = CatalogueMatchListDTO;
      return this.apiClient.callApi(
        '/v1/catalogue/editions/{editionId}/imaged-object-text-fragment-matches', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a listing of all corresponding imaged objects and transcribed text fragment in a specified edition
     * @param {Number} editionId Unique Id of the edition to search for imaged objects to text fragment matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CatalogueMatchListDTO}
     */
    v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGet(editionId) {
      return this.v1CatalogueEditionsEditionIdImagedObjectTextFragmentMatchesGetWithHttpInfo(editionId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a listing of all text fragments matches that correspond to an imaged object
     * @param {String} imagedObjectId Id of imaged object to search for transcription matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CatalogueMatchListDTO} and HTTP response
     */
    v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGetWithHttpInfo(imagedObjectId) {
      let postBody = null;
      // verify the required parameter 'imagedObjectId' is set
      if (imagedObjectId === undefined || imagedObjectId === null) {
        throw new Error("Missing the required parameter 'imagedObjectId' when calling v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet");
      }

      let pathParams = {
        'imagedObjectId': imagedObjectId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['Bearer'];
      let contentTypes = [];
      let accepts = ['text/plain', 'application/json', 'text/json'];
      let returnType = CatalogueMatchListDTO;
      return this.apiClient.callApi(
        '/v1/catalogue/imaged-objects/{imagedObjectId}/text-fragments', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a listing of all text fragments matches that correspond to an imaged object
     * @param {String} imagedObjectId Id of imaged object to search for transcription matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CatalogueMatchListDTO}
     */
    v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGet(imagedObjectId) {
      return this.v1CatalogueImagedObjectsImagedObjectIdTextFragmentsGetWithHttpInfo(imagedObjectId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a listing of all corresponding imaged objects and transcribed text fragment in a specified manuscript
     * @param {Number} manuscriptId Unique Id of the manuscript to search for imaged objects to text fragment matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CatalogueMatchListDTO} and HTTP response
     */
    v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGetWithHttpInfo(manuscriptId) {
      let postBody = null;
      // verify the required parameter 'manuscriptId' is set
      if (manuscriptId === undefined || manuscriptId === null) {
        throw new Error("Missing the required parameter 'manuscriptId' when calling v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet");
      }

      let pathParams = {
        'manuscriptId': manuscriptId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['Bearer'];
      let contentTypes = [];
      let accepts = ['text/plain', 'application/json', 'text/json'];
      let returnType = CatalogueMatchListDTO;
      return this.apiClient.callApi(
        '/v1/catalogue/manuscripts/{manuscriptId}/imaged-object-text-fragment-matches', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a listing of all corresponding imaged objects and transcribed text fragment in a specified manuscript
     * @param {Number} manuscriptId Unique Id of the manuscript to search for imaged objects to text fragment matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CatalogueMatchListDTO}
     */
    v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGet(manuscriptId) {
      return this.v1CatalogueManuscriptsManuscriptIdImagedObjectTextFragmentMatchesGetWithHttpInfo(manuscriptId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a new matched pair for an imaged object and a text fragment along with the edition princeps information
     * @param {Object} opts Optional parameters
     * @param {module:model/CatalogueMatchInputDTO} opts.catalogueMatchInputDTO The details of the new match
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    v1CataloguePostWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = opts['catalogueMatchInputDTO'];

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['Bearer'];
      let contentTypes = ['application/json', 'text/json', 'application/_*+json'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/v1/catalogue', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a new matched pair for an imaged object and a text fragment along with the edition princeps information
     * @param {Object} opts Optional parameters
     * @param {module:model/CatalogueMatchInputDTO} opts.catalogueMatchInputDTO The details of the new match
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    v1CataloguePost(opts) {
      return this.v1CataloguePostWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a listing of all imaged objects that matches that correspond to a transcribed text fragment
     * @param {Number} textFragmentId Unique Id of the text fragment to search for imaged object matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CatalogueMatchListDTO} and HTTP response
     */
    v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGetWithHttpInfo(textFragmentId) {
      let postBody = null;
      // verify the required parameter 'textFragmentId' is set
      if (textFragmentId === undefined || textFragmentId === null) {
        throw new Error("Missing the required parameter 'textFragmentId' when calling v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet");
      }

      let pathParams = {
        'textFragmentId': textFragmentId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['Bearer'];
      let contentTypes = [];
      let accepts = ['text/plain', 'application/json', 'text/json'];
      let returnType = CatalogueMatchListDTO;
      return this.apiClient.callApi(
        '/v1/catalogue/text-fragments/{textFragmentId}/imaged-objects', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a listing of all imaged objects that matches that correspond to a transcribed text fragment
     * @param {Number} textFragmentId Unique Id of the text fragment to search for imaged object matches
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CatalogueMatchListDTO}
     */
    v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGet(textFragmentId) {
      return this.v1CatalogueTextFragmentsTextFragmentIdImagedObjectsGetWithHttpInfo(textFragmentId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
