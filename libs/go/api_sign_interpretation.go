/*
 * SQE API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package qumranica_api_connector

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// SignInterpretationApiService SignInterpretationApi service
type SignInterpretationApiService service

/*
V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete Delete an attribute from an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being edited
 * @param attributeId The ID of the attribute to delete
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(ctx _context.Context, editionId int32, attributeId int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.QueryEscape(parameterToString(attributeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutOpts Optional parameters for the method 'V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut'
type V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutOpts struct {
    UpdateAttributeDto optional.Interface
}

/*
V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut Change the details of an attribute in an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being edited
 * @param attributeId The ID of the attribute to update
 * @param optional nil or *V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutOpts - Optional Parameters:
 * @param "UpdateAttributeDto" (optional.Interface of UpdateAttributeDto) -  The details of the updated attribute
@return AttributeDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(ctx _context.Context, editionId int32, attributeId int32, localVarOptionals *V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutOpts) (AttributeDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.QueryEscape(parameterToString(attributeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.UpdateAttributeDto.IsSet() {
		localVarOptionalUpdateAttributeDto, localVarOptionalUpdateAttributeDtook := localVarOptionals.UpdateAttributeDto.Value().(UpdateAttributeDto)
		if !localVarOptionalUpdateAttributeDtook {
			return localVarReturnValue, nil, reportError("updateAttributeDto should be UpdateAttributeDto")
		}
		localVarPostBody = &localVarOptionalUpdateAttributeDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdSignInterpretationsAttributesGet Retrieve a list of all possible attributes for an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being searched
@return AttributeListDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesGet(ctx _context.Context, editionId int32) (AttributeListDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations-attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdSignInterpretationsAttributesPostOpts Optional parameters for the method 'V1EditionsEditionIdSignInterpretationsAttributesPost'
type V1EditionsEditionIdSignInterpretationsAttributesPostOpts struct {
    CreateAttributeDto optional.Interface
}

/*
V1EditionsEditionIdSignInterpretationsAttributesPost Create a new attribute for an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being edited
 * @param optional nil or *V1EditionsEditionIdSignInterpretationsAttributesPostOpts - Optional Parameters:
 * @param "CreateAttributeDto" (optional.Interface of CreateAttributeDto) -  The details of the new attribute
@return AttributeDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesPost(ctx _context.Context, editionId int32, localVarOptionals *V1EditionsEditionIdSignInterpretationsAttributesPostOpts) (AttributeDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations-attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.CreateAttributeDto.IsSet() {
		localVarOptionalCreateAttributeDto, localVarOptionalCreateAttributeDtook := localVarOptionals.CreateAttributeDto.Value().(CreateAttributeDto)
		if !localVarOptionalCreateAttributeDtook {
			return localVarReturnValue, nil, reportError("createAttributeDto should be CreateAttributeDto")
		}
		localVarPostBody = &localVarOptionalCreateAttributeDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdSignInterpretationsPostOpts Optional parameters for the method 'V1EditionsEditionIdSignInterpretationsPost'
type V1EditionsEditionIdSignInterpretationsPostOpts struct {
    SignInterpretationCreateDto optional.Interface
}

/*
V1EditionsEditionIdSignInterpretationsPost Creates a new sign interpretation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param optional nil or *V1EditionsEditionIdSignInterpretationsPostOpts - Optional Parameters:
 * @param "SignInterpretationCreateDto" (optional.Interface of SignInterpretationCreateDto) -  New sign interpretation data to be added
@return SignInterpretationListDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsPost(ctx _context.Context, editionId int32, localVarOptionals *V1EditionsEditionIdSignInterpretationsPostOpts) (SignInterpretationListDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationListDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.SignInterpretationCreateDto.IsSet() {
		localVarOptionalSignInterpretationCreateDto, localVarOptionalSignInterpretationCreateDtook := localVarOptionals.SignInterpretationCreateDto.Value().(SignInterpretationCreateDto)
		if !localVarOptionalSignInterpretationCreateDtook {
			return localVarReturnValue, nil, reportError("signInterpretationCreateDto should be SignInterpretationCreateDto")
		}
		localVarPostBody = &localVarOptionalSignInterpretationCreateDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete This deletes the specified attribute value from the specified sign interpretation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation being altered
 * @param attributeValueId Id of the attribute being removed
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(ctx _context.Context, editionId int32, signInterpretationId int32, attributeValueId int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"attributeValueId"+"}", _neturl.QueryEscape(parameterToString(attributeValueId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutOpts Optional parameters for the method 'V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut'
type V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutOpts struct {
    InterpretationAttributeCreateDto optional.Interface
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation being altered
 * @param attributeValueId Id of the attribute value to be altered
 * @param optional nil or *V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutOpts - Optional Parameters:
 * @param "InterpretationAttributeCreateDto" (optional.Interface of InterpretationAttributeCreateDto) -  New details of the attribute
@return SignInterpretationDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(ctx _context.Context, editionId int32, signInterpretationId int32, attributeValueId int32, localVarOptionals *V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutOpts) (SignInterpretationDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"attributeValueId"+"}", _neturl.QueryEscape(parameterToString(attributeValueId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.InterpretationAttributeCreateDto.IsSet() {
		localVarOptionalInterpretationAttributeCreateDto, localVarOptionalInterpretationAttributeCreateDtook := localVarOptionals.InterpretationAttributeCreateDto.Value().(InterpretationAttributeCreateDto)
		if !localVarOptionalInterpretationAttributeCreateDtook {
			return localVarReturnValue, nil, reportError("interpretationAttributeCreateDto should be InterpretationAttributeCreateDto")
		}
		localVarPostBody = &localVarOptionalInterpretationAttributeCreateDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostOpts Optional parameters for the method 'V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost'
type V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostOpts struct {
    InterpretationAttributeCreateDto optional.Interface
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost This adds a new attribute to the specified sign interpretation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation for adding a new attribute
 * @param optional nil or *V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostOpts - Optional Parameters:
 * @param "InterpretationAttributeCreateDto" (optional.Interface of InterpretationAttributeCreateDto) -  Details of the attribute to be added
@return SignInterpretationDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(ctx _context.Context, editionId int32, signInterpretationId int32, localVarOptionals *V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostOpts) (SignInterpretationDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.InterpretationAttributeCreateDto.IsSet() {
		localVarOptionalInterpretationAttributeCreateDto, localVarOptionalInterpretationAttributeCreateDtook := localVarOptionals.InterpretationAttributeCreateDto.Value().(InterpretationAttributeCreateDto)
		if !localVarOptionalInterpretationAttributeCreateDtook {
			return localVarReturnValue, nil, reportError("interpretationAttributeCreateDto should be InterpretationAttributeCreateDto")
		}
		localVarPostBody = &localVarOptionalInterpretationAttributeCreateDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutOpts Optional parameters for the method 'V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut'
type V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutOpts struct {
    CommentaryCreateDto optional.Interface
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut Updates the commentary of a sign interpretation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation whose commentary is being changed
 * @param optional nil or *V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutOpts - Optional Parameters:
 * @param "CommentaryCreateDto" (optional.Interface of CommentaryCreateDto) -  The new commentary for the sign interpretation
@return SignInterpretationDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(ctx _context.Context, editionId int32, signInterpretationId int32, localVarOptionals *V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutOpts) (SignInterpretationDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/commentary"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.CommentaryCreateDto.IsSet() {
		localVarOptionalCommentaryCreateDto, localVarOptionalCommentaryCreateDtook := localVarOptionals.CommentaryCreateDto.Value().(CommentaryCreateDto)
		if !localVarOptionalCommentaryCreateDtook {
			return localVarReturnValue, nil, reportError("commentaryCreateDto should be CommentaryCreateDto")
		}
		localVarPostBody = &localVarOptionalCommentaryCreateDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign's next and previous nodes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation being deleted
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(ctx _context.Context, editionId int32, signInterpretationId int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdGet Retrieve the details of a sign interpretation in an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being searched
 * @param signInterpretationId The desired sign interpretation id
@return SignInterpretationDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(ctx _context.Context, editionId int32, signInterpretationId int32) (SignInterpretationDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost Links two sign interpretations in the edition's sign stream
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId The sign interpretation to be linked to the nextSignInterpretationId
 * @param nextSignInterpretationId The sign interpretation to become the new next sign interpretation
@return SignInterpretationDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(ctx _context.Context, editionId int32, signInterpretationId int32, nextSignInterpretationId int32) (SignInterpretationDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/link-to/{nextSignInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"nextSignInterpretationId"+"}", _neturl.QueryEscape(parameterToString(nextSignInterpretationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost Links two sign interpretations in the edition's sign stream
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId The sign interpretation to be unlinked from the nextSignInterpretationId
 * @param nextSignInterpretationId The sign interpretation to removed as next sign interpretation
@return SignInterpretationDto
*/
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(ctx _context.Context, editionId int32, signInterpretationId int32, nextSignInterpretationId int32) (SignInterpretationDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/unlink-from/{nextSignInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.QueryEscape(parameterToString(signInterpretationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"nextSignInterpretationId"+"}", _neturl.QueryEscape(parameterToString(nextSignInterpretationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
