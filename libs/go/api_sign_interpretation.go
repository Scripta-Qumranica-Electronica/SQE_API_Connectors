/*
 * SQE API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SignInterpretationApiService SignInterpretationApi service
type SignInterpretationApiService service

type ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	attributeId int32
}


func (r ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete Delete an attribute from an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being edited
 * @param attributeId The ID of the attribute to delete
 * @return ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete(ctx _context.Context, editionId int32, attributeId int32) ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest {
	return ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		attributeId: attributeId,
	}
}

/*
 * Execute executes the request
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteExecute(r ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsAttributesAttributeIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.PathEscape(parameterToString(r.attributeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	attributeId int32
	updateAttributeDTO *UpdateAttributeDTO
}

func (r ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest) UpdateAttributeDTO(updateAttributeDTO UpdateAttributeDTO) ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest {
	r.updateAttributeDTO = &updateAttributeDTO
	return r
}

func (r ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest) Execute() (AttributeDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut Change the details of an attribute in an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being edited
 * @param attributeId The ID of the attribute to update
 * @return ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut(ctx _context.Context, editionId int32, attributeId int32) ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest {
	return ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		attributeId: attributeId,
	}
}

/*
 * Execute executes the request
 * @return AttributeDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutExecute(r ApiV1EditionsEditionIdSignInterpretationsAttributesAttributeIdPutRequest) (AttributeDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsAttributesAttributeIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations-attributes/{attributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.PathEscape(parameterToString(r.attributeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAttributeDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsAttributesGetRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
}


func (r ApiV1EditionsEditionIdSignInterpretationsAttributesGetRequest) Execute() (AttributeListDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsAttributesGetExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsAttributesGet Retrieve a list of all possible attributes for an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being searched
 * @return ApiV1EditionsEditionIdSignInterpretationsAttributesGetRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesGet(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdSignInterpretationsAttributesGetRequest {
	return ApiV1EditionsEditionIdSignInterpretationsAttributesGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return AttributeListDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesGetExecute(r ApiV1EditionsEditionIdSignInterpretationsAttributesGetRequest) (AttributeListDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsAttributesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations-attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	createAttributeDTO *CreateAttributeDTO
}

func (r ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest) CreateAttributeDTO(createAttributeDTO CreateAttributeDTO) ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest {
	r.createAttributeDTO = &createAttributeDTO
	return r
}

func (r ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest) Execute() (AttributeDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsAttributesPostExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsAttributesPost Create a new attribute for an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being edited
 * @return ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesPost(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest {
	return ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return AttributeDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsAttributesPostExecute(r ApiV1EditionsEditionIdSignInterpretationsAttributesPostRequest) (AttributeDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsAttributesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations-attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAttributeDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsPostRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationCreateDTO *SignInterpretationCreateDTO
}

func (r ApiV1EditionsEditionIdSignInterpretationsPostRequest) SignInterpretationCreateDTO(signInterpretationCreateDTO SignInterpretationCreateDTO) ApiV1EditionsEditionIdSignInterpretationsPostRequest {
	r.signInterpretationCreateDTO = &signInterpretationCreateDTO
	return r
}

func (r ApiV1EditionsEditionIdSignInterpretationsPostRequest) Execute() (SignInterpretationListDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsPostExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsPost Creates a new sign interpretation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @return ApiV1EditionsEditionIdSignInterpretationsPostRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsPost(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdSignInterpretationsPostRequest {
	return ApiV1EditionsEditionIdSignInterpretationsPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return SignInterpretationListDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsPostExecute(r ApiV1EditionsEditionIdSignInterpretationsPostRequest) (SignInterpretationListDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signInterpretationCreateDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
	attributeValueId int32
}


func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete This deletes the specified attribute value from the specified sign interpretation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation being altered
 * @param attributeValueId Id of the attribute being removed
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete(ctx _context.Context, editionId int32, signInterpretationId int32, attributeValueId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
		attributeValueId: attributeValueId,
	}
}

/*
 * Execute executes the request
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attributeValueId"+"}", _neturl.PathEscape(parameterToString(r.attributeValueId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
	attributeValueId int32
	interpretationAttributeCreateDTO *InterpretationAttributeCreateDTO
}

func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest) InterpretationAttributeCreateDTO(interpretationAttributeCreateDTO InterpretationAttributeCreateDTO) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest {
	r.interpretationAttributeCreateDTO = &interpretationAttributeCreateDTO
	return r
}

func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest) Execute() (SignInterpretationDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut This changes the values of the specified sign interpretation attribute,  mainly used to change commentary.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation being altered
 * @param attributeValueId Id of the attribute value to be altered
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut(ctx _context.Context, editionId int32, signInterpretationId int32, attributeValueId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
		attributeValueId: attributeValueId,
	}
}

/*
 * Execute executes the request
 * @return SignInterpretationDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPutRequest) (SignInterpretationDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesAttributeValueIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes/{attributeValueId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attributeValueId"+"}", _neturl.PathEscape(parameterToString(r.attributeValueId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interpretationAttributeCreateDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
	interpretationAttributeCreateDTO *InterpretationAttributeCreateDTO
}

func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest) InterpretationAttributeCreateDTO(interpretationAttributeCreateDTO InterpretationAttributeCreateDTO) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest {
	r.interpretationAttributeCreateDTO = &interpretationAttributeCreateDTO
	return r
}

func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest) Execute() (SignInterpretationDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost This adds a new attribute to the specified sign interpretation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation for adding a new attribute
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost(ctx _context.Context, editionId int32, signInterpretationId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
	}
}

/*
 * Execute executes the request
 * @return SignInterpretationDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPostRequest) (SignInterpretationDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdAttributesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interpretationAttributeCreateDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
	commentaryCreateDTO *CommentaryCreateDTO
}

func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest) CommentaryCreateDTO(commentaryCreateDTO CommentaryCreateDTO) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest {
	r.commentaryCreateDTO = &commentaryCreateDTO
	return r
}

func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest) Execute() (SignInterpretationDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut Updates the commentary of a sign interpretation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation whose commentary is being changed
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut(ctx _context.Context, editionId int32, signInterpretationId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
	}
}

/*
 * Execute executes the request
 * @return SignInterpretationDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPutRequest) (SignInterpretationDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdCommentaryPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/commentary"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.commentaryCreateDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
}


func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete Deletes the sign interpretation in the route. The endpoint automatically manages the sign stream  by connecting all the deleted sign's next and previous nodes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId ID of the sign interpretation being deleted
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete(ctx _context.Context, editionId int32, signInterpretationId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
	}
}

/*
 * Execute executes the request
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
}


func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest) Execute() (SignInterpretationDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdGetExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdGet Retrieve the details of a sign interpretation in an edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId The ID of the edition being searched
 * @param signInterpretationId The desired sign interpretation id
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdGet(ctx _context.Context, editionId int32, signInterpretationId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
	}
}

/*
 * Execute executes the request
 * @return SignInterpretationDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdGetExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdGetRequest) (SignInterpretationDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
	nextSignInterpretationId int32
}


func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest) Execute() (SignInterpretationDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost Links two sign interpretations in the edition's sign stream
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId The sign interpretation to be linked to the nextSignInterpretationId
 * @param nextSignInterpretationId The sign interpretation to become the new next sign interpretation
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost(ctx _context.Context, editionId int32, signInterpretationId int32, nextSignInterpretationId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
		nextSignInterpretationId: nextSignInterpretationId,
	}
}

/*
 * Execute executes the request
 * @return SignInterpretationDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPostRequest) (SignInterpretationDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdLinkToNextSignInterpretationIdPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/link-to/{nextSignInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nextSignInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.nextSignInterpretationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest struct {
	ctx _context.Context
	ApiService *SignInterpretationApiService
	editionId int32
	signInterpretationId int32
	nextSignInterpretationId int32
}


func (r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest) Execute() (SignInterpretationDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostExecute(r)
}

/*
 * V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost Links two sign interpretations in the edition's sign stream
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId ID of the edition being changed
 * @param signInterpretationId The sign interpretation to be unlinked from the nextSignInterpretationId
 * @param nextSignInterpretationId The sign interpretation to removed as next sign interpretation
 * @return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost(ctx _context.Context, editionId int32, signInterpretationId int32, nextSignInterpretationId int32) ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest {
	return ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		signInterpretationId: signInterpretationId,
		nextSignInterpretationId: nextSignInterpretationId,
	}
}

/*
 * Execute executes the request
 * @return SignInterpretationDTO
 */
func (a *SignInterpretationApiService) V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostExecute(r ApiV1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPostRequest) (SignInterpretationDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignInterpretationDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SignInterpretationApiService.V1EditionsEditionIdSignInterpretationsSignInterpretationIdUnlinkFromNextSignInterpretationIdPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/sign-interpretations/{signInterpretationId}/unlink-from/{nextSignInterpretationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"signInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.signInterpretationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nextSignInterpretationId"+"}", _neturl.PathEscape(parameterToString(r.nextSignInterpretationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
