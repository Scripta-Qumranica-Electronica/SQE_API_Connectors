/*
 * SQE API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// ArtefactApiService ArtefactApi service
type ArtefactApiService service

type ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactGroupId int32
}


func (r ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest) Execute() (DeleteDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteExecute(r)
}

/*
 * V1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete Deletes the specified artefact group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactGroupId Unique Id of the artefact group to be deleted
 * @return ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete(ctx _context.Context, editionId int32, artefactGroupId int32) ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest {
	return ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactGroupId: artefactGroupId,
	}
}

/*
 * Execute executes the request
 * @return DeleteDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteExecute(r ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdDeleteRequest) (DeleteDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeleteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactGroupsArtefactGroupIdDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefact-groups/{artefactGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactGroupId"+"}", _neturl.PathEscape(parameterToString(r.artefactGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactGroupId int32
}


func (r ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest) Execute() (ArtefactGroupDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactGroupsArtefactGroupIdGetExecute(r)
}

/*
 * V1EditionsEditionIdArtefactGroupsArtefactGroupIdGet Gets the details of a specific artefact group in the edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactGroupId Id of the desired artefact group
 * @return ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsArtefactGroupIdGet(ctx _context.Context, editionId int32, artefactGroupId int32) ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest {
	return ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactGroupId: artefactGroupId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactGroupDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsArtefactGroupIdGetExecute(r ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdGetRequest) (ArtefactGroupDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactGroupDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactGroupsArtefactGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefact-groups/{artefactGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactGroupId"+"}", _neturl.PathEscape(parameterToString(r.artefactGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactGroupId int32
	updateArtefactGroupDTO *UpdateArtefactGroupDTO
}

func (r ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest) UpdateArtefactGroupDTO(updateArtefactGroupDTO UpdateArtefactGroupDTO) ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest {
	r.updateArtefactGroupDTO = &updateArtefactGroupDTO
	return r
}

func (r ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest) Execute() (ArtefactGroupDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactGroupsArtefactGroupIdPutExecute(r)
}

/*
 * V1EditionsEditionIdArtefactGroupsArtefactGroupIdPut Updates the details of an artefact group.  The artefact group will now only contain the artefacts listed in the JSON payload.  If the name is null, no change will be made, otherwise the name will also be updated.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactGroupId Id of the artefact group to be updated
 * @return ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsArtefactGroupIdPut(ctx _context.Context, editionId int32, artefactGroupId int32) ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest {
	return ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactGroupId: artefactGroupId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactGroupDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsArtefactGroupIdPutExecute(r ApiV1EditionsEditionIdArtefactGroupsArtefactGroupIdPutRequest) (ArtefactGroupDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactGroupDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactGroupsArtefactGroupIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefact-groups/{artefactGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactGroupId"+"}", _neturl.PathEscape(parameterToString(r.artefactGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateArtefactGroupDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactGroupsGetRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
}


func (r ApiV1EditionsEditionIdArtefactGroupsGetRequest) Execute() (ArtefactGroupListDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactGroupsGetExecute(r)
}

/*
 * V1EditionsEditionIdArtefactGroupsGet Gets a listing of all artefact groups in the edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @return ApiV1EditionsEditionIdArtefactGroupsGetRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsGet(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdArtefactGroupsGetRequest {
	return ApiV1EditionsEditionIdArtefactGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactGroupListDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsGetExecute(r ApiV1EditionsEditionIdArtefactGroupsGetRequest) (ArtefactGroupListDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactGroupListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefact-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactGroupsPostRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	createArtefactGroupDTO *CreateArtefactGroupDTO
}

func (r ApiV1EditionsEditionIdArtefactGroupsPostRequest) CreateArtefactGroupDTO(createArtefactGroupDTO CreateArtefactGroupDTO) ApiV1EditionsEditionIdArtefactGroupsPostRequest {
	r.createArtefactGroupDTO = &createArtefactGroupDTO
	return r
}

func (r ApiV1EditionsEditionIdArtefactGroupsPostRequest) Execute() (ArtefactGroupDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactGroupsPostExecute(r)
}

/*
 * V1EditionsEditionIdArtefactGroupsPost Creates a new artefact group with the submitted data.  The new artefact must have a list of artefacts that belong to the group.  It is not necessary to give the group a name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @return ApiV1EditionsEditionIdArtefactGroupsPostRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsPost(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdArtefactGroupsPostRequest {
	return ApiV1EditionsEditionIdArtefactGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactGroupDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactGroupsPostExecute(r ApiV1EditionsEditionIdArtefactGroupsPostRequest) (ArtefactGroupDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactGroupDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactGroupsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefact-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createArtefactGroupDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsArtefactIdDeleteRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactId int32
}


func (r ApiV1EditionsEditionIdArtefactsArtefactIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsArtefactIdDeleteExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsArtefactIdDelete Deletes the specified artefact
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactId Unique Id of the desired artefact
 * @return ApiV1EditionsEditionIdArtefactsArtefactIdDeleteRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdDelete(ctx _context.Context, editionId int32, artefactId int32) ApiV1EditionsEditionIdArtefactsArtefactIdDeleteRequest {
	return ApiV1EditionsEditionIdArtefactsArtefactIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactId: artefactId,
	}
}

/*
 * Execute executes the request
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdDeleteExecute(r ApiV1EditionsEditionIdArtefactsArtefactIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsArtefactIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts/{artefactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactId"+"}", _neturl.PathEscape(parameterToString(r.artefactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactId int32
	optional *[]string
}

func (r ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest) Optional(optional []string) ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest {
	r.optional = &optional
	return r
}

func (r ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest) Execute() (ArtefactDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsArtefactIdGetExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsArtefactIdGet Provides a listing of all artefacts that are part of the specified edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactId Unique Id of the desired artefact
 * @return ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdGet(ctx _context.Context, editionId int32, artefactId int32) ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest {
	return ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactId: artefactId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdGetExecute(r ApiV1EditionsEditionIdArtefactsArtefactIdGetRequest) (ArtefactDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsArtefactIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts/{artefactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactId"+"}", _neturl.PathEscape(parameterToString(r.artefactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.optional != nil {
		t := *r.optional
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("optional", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("optional", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactId int32
	updateArtefactDTO *UpdateArtefactDTO
}

func (r ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest) UpdateArtefactDTO(updateArtefactDTO UpdateArtefactDTO) ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest {
	r.updateArtefactDTO = &updateArtefactDTO
	return r
}

func (r ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest) Execute() (ArtefactDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsArtefactIdPutExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsArtefactIdPut Updates the specified artefact.  There are many possible attributes that can be changed for  an artefact.  The caller should only input only those that  should be changed. Attributes with a null value will be ignored.  For instance, setting the mask to null or \"\" will result in  no changes to the current mask, and no value for the mask will  be returned (or broadcast). Likewise, the transformation, name,  or status message may be set to null and no change will be made  to those entities (though any unchanged values will be returned  along with the changed values and also broadcast to co-editors).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactId Unique Id of the desired artefact
 * @return ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdPut(ctx _context.Context, editionId int32, artefactId int32) ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest {
	return ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactId: artefactId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdPutExecute(r ApiV1EditionsEditionIdArtefactsArtefactIdPutRequest) (ArtefactDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsArtefactIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts/{artefactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactId"+"}", _neturl.PathEscape(parameterToString(r.artefactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateArtefactDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsArtefactIdRoisGetRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactId int32
}


func (r ApiV1EditionsEditionIdArtefactsArtefactIdRoisGetRequest) Execute() (InterpretationRoiDTOList, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsArtefactIdRoisGetExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsArtefactIdRoisGet Provides a listing of all rois belonging to an artefact in the specified edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactId Unique Id of the desired artefact
 * @return ApiV1EditionsEditionIdArtefactsArtefactIdRoisGetRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdRoisGet(ctx _context.Context, editionId int32, artefactId int32) ApiV1EditionsEditionIdArtefactsArtefactIdRoisGetRequest {
	return ApiV1EditionsEditionIdArtefactsArtefactIdRoisGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactId: artefactId,
	}
}

/*
 * Execute executes the request
 * @return InterpretationRoiDTOList
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdRoisGetExecute(r ApiV1EditionsEditionIdArtefactsArtefactIdRoisGetRequest) (InterpretationRoiDTOList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InterpretationRoiDTOList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsArtefactIdRoisGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts/{artefactId}/rois"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactId"+"}", _neturl.PathEscape(parameterToString(r.artefactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	artefactId int32
	optional *[]string
}

func (r ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest) Optional(optional []string) ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest {
	r.optional = &optional
	return r
}

func (r ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest) Execute() (ArtefactTextFragmentMatchListDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet Provides a listing of text fragments that have text in the specified artefact.  With the optional query parameter \"suggested\", this endpoint will also return  any text fragment that the system suggests might have text in the artefact.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @param artefactId Unique Id of the desired artefact
 * @return ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet(ctx _context.Context, editionId int32, artefactId int32) ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest {
	return ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
		artefactId: artefactId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactTextFragmentMatchListDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetExecute(r ApiV1EditionsEditionIdArtefactsArtefactIdTextFragmentsGetRequest) (ArtefactTextFragmentMatchListDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactTextFragmentMatchListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsArtefactIdTextFragmentsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts/{artefactId}/text-fragments"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artefactId"+"}", _neturl.PathEscape(parameterToString(r.artefactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.optional != nil {
		t := *r.optional
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("optional", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("optional", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	batchUpdateArtefactPlacementDTO *BatchUpdateArtefactPlacementDTO
}

func (r ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest) BatchUpdateArtefactPlacementDTO(batchUpdateArtefactPlacementDTO BatchUpdateArtefactPlacementDTO) ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest {
	r.batchUpdateArtefactPlacementDTO = &batchUpdateArtefactPlacementDTO
	return r
}

func (r ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest) Execute() (BatchUpdatedArtefactTransformDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsBatchTransformationPostExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsBatchTransformationPost Updates the positional data for a batch of artefacts
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @return ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsBatchTransformationPost(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest {
	return ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return BatchUpdatedArtefactTransformDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsBatchTransformationPostExecute(r ApiV1EditionsEditionIdArtefactsBatchTransformationPostRequest) (BatchUpdatedArtefactTransformDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BatchUpdatedArtefactTransformDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsBatchTransformationPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts/batch-transformation"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchUpdateArtefactPlacementDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsGetRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	optional *[]string
}

func (r ApiV1EditionsEditionIdArtefactsGetRequest) Optional(optional []string) ApiV1EditionsEditionIdArtefactsGetRequest {
	r.optional = &optional
	return r
}

func (r ApiV1EditionsEditionIdArtefactsGetRequest) Execute() (ArtefactListDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsGetExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsGet Provides a listing of all artefacts that are part of the specified edition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @return ApiV1EditionsEditionIdArtefactsGetRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsGet(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdArtefactsGetRequest {
	return ApiV1EditionsEditionIdArtefactsGetRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactListDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsGetExecute(r ApiV1EditionsEditionIdArtefactsGetRequest) (ArtefactListDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactListDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.optional != nil {
		t := *r.optional
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("optional", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("optional", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EditionsEditionIdArtefactsPostRequest struct {
	ctx _context.Context
	ApiService *ArtefactApiService
	editionId int32
	createArtefactDTO *CreateArtefactDTO
}

func (r ApiV1EditionsEditionIdArtefactsPostRequest) CreateArtefactDTO(createArtefactDTO CreateArtefactDTO) ApiV1EditionsEditionIdArtefactsPostRequest {
	r.createArtefactDTO = &createArtefactDTO
	return r
}

func (r ApiV1EditionsEditionIdArtefactsPostRequest) Execute() (ArtefactDTO, *_nethttp.Response, error) {
	return r.ApiService.V1EditionsEditionIdArtefactsPostExecute(r)
}

/*
 * V1EditionsEditionIdArtefactsPost Creates a new artefact with the provided data.  If no mask is provided, a placeholder mask will be created with the values:  \"POLYGON((0 0,1 1,1 0,0 0))\" (the system requires a valid WKT polygon mask for  every artefact). It is not recommended to leave the mask, name, or work status  blank or null. It will often be advantageous to leave the transformation null  when first creating a new artefact.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Unique Id of the desired edition
 * @return ApiV1EditionsEditionIdArtefactsPostRequest
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsPost(ctx _context.Context, editionId int32) ApiV1EditionsEditionIdArtefactsPostRequest {
	return ApiV1EditionsEditionIdArtefactsPostRequest{
		ApiService: a,
		ctx: ctx,
		editionId: editionId,
	}
}

/*
 * Execute executes the request
 * @return ArtefactDTO
 */
func (a *ArtefactApiService) V1EditionsEditionIdArtefactsPostExecute(r ApiV1EditionsEditionIdArtefactsPostRequest) (ArtefactDTO, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ArtefactDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtefactApiService.V1EditionsEditionIdArtefactsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/editions/{editionId}/artefacts"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.PathEscape(parameterToString(r.editionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createArtefactDTO
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
