/*
 * SQE API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package qumranica_api_connector

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// RoiApiService RoiApi service
type RoiApiService service

// V1EditionsEditionIdRoisBatchEditPostOpts Optional parameters for the method 'V1EditionsEditionIdRoisBatchEditPost'
type V1EditionsEditionIdRoisBatchEditPostOpts struct {
    BatchEditRoiDto optional.Interface
}

/*
V1EditionsEditionIdRoisBatchEditPost Processes a series of create/update/delete ROI requests in the given edition of a scroll
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Id of the edition
 * @param optional nil or *V1EditionsEditionIdRoisBatchEditPostOpts - Optional Parameters:
 * @param "BatchEditRoiDto" (optional.Interface of BatchEditRoiDto) -  A JSON object with all the roi edits to be performed
@return BatchEditRoiResponseDto
*/
func (a *RoiApiService) V1EditionsEditionIdRoisBatchEditPost(ctx _context.Context, editionId int32, localVarOptionals *V1EditionsEditionIdRoisBatchEditPostOpts) (BatchEditRoiResponseDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BatchEditRoiResponseDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/rois/batch-edit"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.BatchEditRoiDto.IsSet() {
		localVarOptionalBatchEditRoiDto, localVarOptionalBatchEditRoiDtook := localVarOptionals.BatchEditRoiDto.Value().(BatchEditRoiDto)
		if !localVarOptionalBatchEditRoiDtook {
			return localVarReturnValue, nil, reportError("batchEditRoiDto should be BatchEditRoiDto")
		}
		localVarPostBody = &localVarOptionalBatchEditRoiDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdRoisBatchPostOpts Optional parameters for the method 'V1EditionsEditionIdRoisBatchPost'
type V1EditionsEditionIdRoisBatchPostOpts struct {
    SetInterpretationRoiDtoList optional.Interface
}

/*
V1EditionsEditionIdRoisBatchPost Creates new sign ROI's in the given edition of a scroll
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Id of the edition
 * @param optional nil or *V1EditionsEditionIdRoisBatchPostOpts - Optional Parameters:
 * @param "SetInterpretationRoiDtoList" (optional.Interface of SetInterpretationRoiDtoList) -  A JSON object with an array of the new ROI's to be created
@return InterpretationRoiDtoList
*/
func (a *RoiApiService) V1EditionsEditionIdRoisBatchPost(ctx _context.Context, editionId int32, localVarOptionals *V1EditionsEditionIdRoisBatchPostOpts) (InterpretationRoiDtoList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InterpretationRoiDtoList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/rois/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.SetInterpretationRoiDtoList.IsSet() {
		localVarOptionalSetInterpretationRoiDtoList, localVarOptionalSetInterpretationRoiDtoListok := localVarOptionals.SetInterpretationRoiDtoList.Value().(SetInterpretationRoiDtoList)
		if !localVarOptionalSetInterpretationRoiDtoListok {
			return localVarReturnValue, nil, reportError("setInterpretationRoiDtoList should be SetInterpretationRoiDtoList")
		}
		localVarPostBody = &localVarOptionalSetInterpretationRoiDtoList
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdRoisBatchPutOpts Optional parameters for the method 'V1EditionsEditionIdRoisBatchPut'
type V1EditionsEditionIdRoisBatchPutOpts struct {
    UpdateInterpretationRoiDtoList optional.Interface
}

/*
V1EditionsEditionIdRoisBatchPut Update existing sign ROI's in the given edition of a scroll
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Id of the edition
 * @param optional nil or *V1EditionsEditionIdRoisBatchPutOpts - Optional Parameters:
 * @param "UpdateInterpretationRoiDtoList" (optional.Interface of UpdateInterpretationRoiDtoList) -  A JSON object with an array of the updated ROI details
@return UpdatedInterpretationRoiDtoList
*/
func (a *RoiApiService) V1EditionsEditionIdRoisBatchPut(ctx _context.Context, editionId int32, localVarOptionals *V1EditionsEditionIdRoisBatchPutOpts) (UpdatedInterpretationRoiDtoList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdatedInterpretationRoiDtoList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/rois/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.UpdateInterpretationRoiDtoList.IsSet() {
		localVarOptionalUpdateInterpretationRoiDtoList, localVarOptionalUpdateInterpretationRoiDtoListok := localVarOptionals.UpdateInterpretationRoiDtoList.Value().(UpdateInterpretationRoiDtoList)
		if !localVarOptionalUpdateInterpretationRoiDtoListok {
			return localVarReturnValue, nil, reportError("updateInterpretationRoiDtoList should be UpdateInterpretationRoiDtoList")
		}
		localVarPostBody = &localVarOptionalUpdateInterpretationRoiDtoList
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdRoisPostOpts Optional parameters for the method 'V1EditionsEditionIdRoisPost'
type V1EditionsEditionIdRoisPostOpts struct {
    SetInterpretationRoiDto optional.Interface
}

/*
V1EditionsEditionIdRoisPost Creates new sign ROI in the given edition of a scroll
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Id of the edition
 * @param optional nil or *V1EditionsEditionIdRoisPostOpts - Optional Parameters:
 * @param "SetInterpretationRoiDto" (optional.Interface of SetInterpretationRoiDto) -  A JSON object with the new ROI to be created
@return InterpretationRoiDto
*/
func (a *RoiApiService) V1EditionsEditionIdRoisPost(ctx _context.Context, editionId int32, localVarOptionals *V1EditionsEditionIdRoisPostOpts) (InterpretationRoiDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InterpretationRoiDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/rois"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.SetInterpretationRoiDto.IsSet() {
		localVarOptionalSetInterpretationRoiDto, localVarOptionalSetInterpretationRoiDtook := localVarOptionals.SetInterpretationRoiDto.Value().(SetInterpretationRoiDto)
		if !localVarOptionalSetInterpretationRoiDtook {
			return localVarReturnValue, nil, reportError("setInterpretationRoiDto should be SetInterpretationRoiDto")
		}
		localVarPostBody = &localVarOptionalSetInterpretationRoiDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdRoisRoiIdDelete Deletes a sign ROI from the given edition of a scroll
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Id of the edition
 * @param roiId Id of the ROI to be deleted
*/
func (a *RoiApiService) V1EditionsEditionIdRoisRoiIdDelete(ctx _context.Context, editionId int32, roiId int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/rois/{roiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"roiId"+"}", _neturl.QueryEscape(parameterToString(roiId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
V1EditionsEditionIdRoisRoiIdGet Get the details for a ROI in the given edition of a scroll
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Id of the edition
 * @param roiId A JSON object with the new ROI to be created
@return InterpretationRoiDto
*/
func (a *RoiApiService) V1EditionsEditionIdRoisRoiIdGet(ctx _context.Context, editionId int32, roiId int32) (InterpretationRoiDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InterpretationRoiDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/rois/{roiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"roiId"+"}", _neturl.QueryEscape(parameterToString(roiId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// V1EditionsEditionIdRoisRoiIdPutOpts Optional parameters for the method 'V1EditionsEditionIdRoisRoiIdPut'
type V1EditionsEditionIdRoisRoiIdPutOpts struct {
    SetInterpretationRoiDto optional.Interface
}

/*
V1EditionsEditionIdRoisRoiIdPut Update an existing sign ROI in the given edition of a scroll
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param editionId Id of the edition
 * @param roiId Id of the ROI to be updated
 * @param optional nil or *V1EditionsEditionIdRoisRoiIdPutOpts - Optional Parameters:
 * @param "SetInterpretationRoiDto" (optional.Interface of SetInterpretationRoiDto) -  A JSON object with the updated ROI details
@return UpdatedInterpretationRoiDto
*/
func (a *RoiApiService) V1EditionsEditionIdRoisRoiIdPut(ctx _context.Context, editionId int32, roiId int32, localVarOptionals *V1EditionsEditionIdRoisRoiIdPutOpts) (UpdatedInterpretationRoiDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdatedInterpretationRoiDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/editions/{editionId}/rois/{roiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"editionId"+"}", _neturl.QueryEscape(parameterToString(editionId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"roiId"+"}", _neturl.QueryEscape(parameterToString(roiId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.SetInterpretationRoiDto.IsSet() {
		localVarOptionalSetInterpretationRoiDto, localVarOptionalSetInterpretationRoiDtook := localVarOptionals.SetInterpretationRoiDto.Value().(SetInterpretationRoiDto)
		if !localVarOptionalSetInterpretationRoiDtook {
			return localVarReturnValue, nil, reportError("setInterpretationRoiDto should be SetInterpretationRoiDto")
		}
		localVarPostBody = &localVarOptionalSetInterpretationRoiDto
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
